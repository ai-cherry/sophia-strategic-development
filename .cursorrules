# Sophia AI Pay Ready Platform - Cursor AI Rules

## Project Overview
You are working on Sophia AI, an AI assistant orchestrator for Pay Ready company. Sophia serves as the central "Pay Ready Brain" that orchestrates multiple AI agents and integrates with business systems.

## Architecture Context
- **Type:** Multi-agent AI orchestrator with flat-to-hierarchical evolution
- **Primary Role:** Business intelligence and automation for Pay Ready
- **Core Integrations:** HubSpot CRM, Gong.io call analysis, Slack communication
- **Data Stack:** PostgreSQL, Redis, Pinecone, Weaviate
- **Infrastructure:** Lambda Labs servers, Vercel frontend deployment

## 🔐 **PERMANENT SECRET MANAGEMENT SOLUTION**

### **CRITICAL: GitHub Organization Secrets Integration**
Sophia AI uses a **PERMANENT** secret management solution that eliminates manual `.env` management:

```
GitHub Organization Secrets (ai-cherry)
           ↓
    GitHub Actions (automatic sync)
           ↓
    Pulumi ESC Environments
           ↓
    Sophia AI Backend (automatic loading)
```

### **✅ What's Automated**
- **Zero Manual Secret Management**: No more `.env` file management
- **Organization-Level Secrets**: All secrets in [GitHub ai-cherry org](https://github.com/ai-cherry)
- **Automatic Sync**: GitHub Actions → Pulumi ESC → Backend
- **Enterprise Security**: No exposed credentials anywhere
- **Forever Solution**: Works automatically without intervention

### **🔑 Secret Access Pattern**
```python
# Backend automatically loads from Pulumi ESC
from backend.core.auto_esc_config import config

# Secrets are automatically available
openai_key = config.openai_api_key
gong_key = config.gong_access_key
```

### **🚫 NEVER DO THESE ANYMORE**
- ❌ Create or manage `.env` files
- ❌ Hardcode API keys or tokens
- ❌ Share secrets in chat/email
- ❌ Manual environment variable setup
- ❌ Local credential configuration

### **✅ ALWAYS USE THESE**
- ✅ GitHub organization secrets for all credentials
- ✅ Pulumi ESC for centralized configuration
- ✅ Automatic backend configuration loading
- ✅ GitHub Actions for secret synchronization

## 🧠 **ENHANCED MCP INTEGRATION (CRITICAL FOR CURSOR AI)**

### **🔄 AUTOMATIC WORKFLOW INTEGRATION**
Cursor AI MUST automatically integrate with MCP servers for seamless development:

#### **AI Memory Auto-Discovery (@ai_memory)**
1. **INTELLIGENT AUTO-STORAGE**: Automatically detect and store:
   - Architecture discussions with decision rationale
   - Bug fixes with root cause analysis
   - Code patterns and implementation strategies
   - Performance optimization insights
   - Security implementation decisions
   - Refactoring approaches and outcomes

2. **CONTEXT-AWARE RECALL**: Before any coding task, automatically:
   - Query relevant past decisions: `@ai_memory.smart_recall("current task context")`
   - Surface similar patterns from project history
   - Provide continuity with previous architectural choices
   - Suggest proven solutions from past implementations

3. **ENHANCED MEMORY TOOLS**:
   - `ai_memory.auto_store_context`: Intelligent conversation analysis and storage
   - `ai_memory.smart_recall`: Context-aware memory retrieval with file awareness
   - `ai_memory.store_conversation`: Manual conversation storage with categorization
   - `ai_memory.recall_memory`: Traditional search with semantic matching

#### **Real-time Code Analysis (@codacy)**
1. **AUTOMATIC CODE QUALITY**: On every significant code change:
   - Real-time security vulnerability scanning
   - Code complexity analysis with refactoring suggestions
   - Style compliance checking (Black, PEP 8)
   - Performance pattern detection

2. **INTELLIGENT SUGGESTIONS**: Proactive recommendations:
   - Security best practices for detected patterns
   - Refactoring opportunities for complex functions
   - Code quality improvements with examples
   - Architecture alignment with project standards

3. **ENHANCED CODACY TOOLS**:
   - `codacy.analyze_code`: Real-time code snippet analysis
   - `codacy.analyze_file`: Complete file quality assessment
   - `codacy.get_fix_suggestions`: Automated improvement recommendations
   - `codacy.security_scan`: Focused security vulnerability detection

### **🚀 WORKFLOW AUTOMATION TRIGGERS**

#### **Automatic Triggers (No User Input Required)**:
- **On File Save**: `@codacy.analyze_file` + `@ai_memory.auto_store_context`
- **On Architecture Discussion**: `@ai_memory.store_conversation(category="architecture")`
- **On Bug Fix**: `@ai_memory.store_conversation(category="bug_solution")` + `@codacy.security_scan`
- **On Code Review**: `@codacy.analyze_code` + `@ai_memory.recall_memory("similar patterns")`

#### **Smart Context Awareness**:
- **File-Specific Memory**: Automatically recall memories related to current file
- **Project Pattern Recognition**: Surface relevant architectural decisions
- **Security Context**: Auto-scan for security issues in sensitive code areas
- **Performance Awareness**: Detect performance-critical code sections

### **🎯 ENHANCED NATURAL LANGUAGE COMMANDS**

#### **Memory Operations**:
- "Remember this architectural decision" → Auto-categorize and store with context
- "What did we decide about database schema?" → Smart recall with file context
- "Show me similar bug fixes" → Context-aware pattern matching
- "Store this conversation about MCP integration" → Enhanced storage with metadata

#### **Code Quality Operations**:
- "Analyze this code for security issues" → Comprehensive security scan
- "Check code quality" → Multi-dimensional analysis with suggestions
- "Fix this function complexity" → Automated refactoring recommendations
- "Scan for vulnerabilities" → Deep security pattern analysis

#### **Integrated Workflows**:
- "Review and remember this implementation" → Codacy analysis + Memory storage
- "Find similar patterns and analyze quality" → Memory recall + Code analysis
- "Store this bug fix and scan for similar issues" → Memory storage + Security scan

### **📊 INTELLIGENT REPORTING**

#### **Development Insights**:
- Automatic pattern recognition across stored memories
- Code quality trends over time
- Security vulnerability patterns
- Architecture evolution tracking

#### **Proactive Recommendations**:
- Suggest architectural improvements based on stored decisions
- Recommend security enhancements from vulnerability patterns
- Propose refactoring based on complexity analysis
- Guide development based on successful past patterns

### **🔧 CURSOR IDE INTEGRATION SPECIFICS**

#### **Configuration Requirements**:
- MCP servers running on specified ports (ai_memory: 9000, codacy: 3008)
- Auto-trigger workflows enabled in cursor_mcp_config.json
- Context awareness enabled for file-specific operations
- Intelligent routing for multi-tool operations

#### **Performance Optimization**:
- Parallel tool execution for independent operations
- Smart caching of frequently accessed memories
- Efficient code analysis with incremental scanning
- Context-aware tool selection based on current activity

### **Example Enhanced Workflow**:
```
User: "I need to implement user authentication for the MCP server"

Cursor AI (Automatic Sequence):
1. [AUTO] @ai_memory.smart_recall("authentication MCP server implementation")
2. [CONTEXT] Retrieve: Previous auth patterns, security decisions, MCP integration approaches
3. [ANALYSIS] @codacy.analyze_code(current_auth_code) for security assessment
4. [RESPONSE] Provide implementation guidance based on stored patterns + security analysis
5. [AUTO] @ai_memory.auto_store_context(conversation + implementation decisions)
```

This enhanced integration transforms Cursor AI into an intelligent development partner that learns from every interaction and provides contextually aware assistance.

## Development Standards

### Python Code Style
- Use Python 3.11+ with type hints for all functions
- Follow PEP 8 with 88-character line limit (Black formatter)
- Use async/await for I/O operations
- Implement comprehensive error handling with logging
- Include detailed docstrings for all classes and methods

### Agent Development Pattern
```python
from backend.agents.core.base_agent import BaseAgent

class YourAgent(BaseAgent):
    def __init__(self, config: AgentConfig):
        super().__init__(config)
        # Agent-specific initialization

    async def execute_task(self, task: Task) -> TaskResult:
        # Implementation with error handling
        pass
```

### Integration Pattern
```python
class ServiceIntegration:
    def __init__(self, config: ServiceConfig):
        self.config = config
        self.client = self._create_client()

    async def _make_request(self, method: str, endpoint: str, **kwargs):
        # Standardized request handling with rate limiting
        pass
```

### Business Intelligence Focus
- Always consider Pay Ready business context
- Implement metrics for revenue, customer health, sales performance
- Focus on actionable insights for sales coaching and client monitoring
- Prioritize real-time data processing and notifications

### Security Requirements
- Use encrypted storage for all API keys
- Implement proper authentication and authorization
- Log all security-relevant events
- Follow principle of least privilege

### **Secret Management (PERMANENT SOLUTION)**
- **Documentation:** Always refer to `PERMANENT_GITHUB_ORG_SECRETS_SOLUTION.md`
- **GitHub Organization:** All secrets managed at [https://github.com/ai-cherry](https://github.com/ai-cherry)
- **Pulumi ESC:** Automatic secret synchronization via `scoobyjava-org/default/sophia-ai-production`
- **Backend Integration:** Use `backend/core/auto_esc_config.py` for automatic secret loading
- **Never hardcode secrets:** Always use automatic ESC integration
- **GitHub Actions:** Secrets automatically available from organization level
- **Local Development:** Set `export PULUMI_ORG=scoobyjava-org` and secrets load automatically
- **Secret Rotation:** Update in GitHub organization → automatic sync → automatic deployment

### Testing Strategy
- Write unit tests for all business logic
- Include integration tests for external APIs
- Implement performance tests for critical paths
- Use pytest with async support

### Error Handling Pattern
```python
try:
    result = await some_operation()
    return result
except SpecificException as e:
    logger.error(f"Operation failed: {e}")
    raise BusinessLogicError(f"Failed to process: {e}")
except Exception as e:
    logger.exception("Unexpected error")
    raise SystemError("Internal system error")
```

## Business Domain Knowledge

### Pay Ready Context
- Company focus: Business intelligence and automation
- Key metrics: Revenue growth, customer satisfaction, sales efficiency
- Team communication: Primarily through Slack
- CRM system: HubSpot for contact and deal management
- Call analysis: Gong.io for sales call insights

### Agent Specializations
- **Call Analysis Agent:** Process Gong.io recordings for insights
- **CRM Sync Agent:** Maintain HubSpot data quality and synchronization
- **Notification Agent:** Send intelligent Slack updates
- **Business Intelligence Agent:** Generate revenue and performance reports

### Integration Priorities
1. **HubSpot:** Primary CRM for contact/deal management
2. **Gong.io:** Critical for call analysis and sales coaching
3. **Slack:** Main communication channel for team updates
4. **Vector Databases:** For semantic search and AI capabilities

## File Organization
```
backend/
├── agents/
│   ├── core/           # Base agent classes
│   └── specialized/    # Domain-specific agents
├── integrations/       # External service integrations
├── database/          # Data layer and migrations
├── monitoring/        # Performance and health monitoring
└── security/          # Authentication and encryption

frontend/
├── src/
│   ├── components/    # React components
│   ├── pages/         # Page components
│   └── services/      # API clients
```

## Common Patterns

### API Client Implementation
- Use aiohttp for async HTTP requests
- Implement exponential backoff for retries
- Respect rate limits with proper throttling
- Include comprehensive error handling

### Database Operations
- Use SQLAlchemy with async support
- Implement proper connection pooling
- Use transactions for data consistency
- Include migration scripts for schema changes

### Monitoring and Logging
- Use structured logging with JSON format
- Include correlation IDs for request tracing
- Monitor performance metrics and business KPIs
- Implement health checks for all services

## AI and ML Guidelines
- Use OpenAI API for language processing
- Implement vector search with Pinecone/Weaviate
- Cache embeddings for performance
- Include confidence scores in AI responses

## Deployment Considerations
- Target Lambda Labs for production deployment
- Use Docker for containerization
- Implement zero-downtime deployment strategies
- Include environment-specific configurations

## Performance Requirements
- API response times < 200ms for critical paths
- Database queries < 100ms average
- Vector searches < 50ms average
- Support for 1000+ concurrent users

## When suggesting code:
1. **FIRST**: Check AI memory for similar implementations
2. Always include proper error handling
3. Add type hints and docstrings
4. Consider business context and Pay Ready needs
5. Implement monitoring and logging
6. Follow the established patterns in the codebase
7. Prioritize performance and scalability
8. Include relevant tests
9. **LAST**: Store the conversation in AI memory

## Avoid:
- Hardcoded values (use configuration)
- Synchronous I/O in async contexts
- Missing error handling
- Unclear variable names
- Complex nested logic without comments
- Security vulnerabilities (exposed secrets, etc.)

Remember: You're building an enterprise-grade AI orchestrator that will handle critical business operations for Pay Ready. Code quality, reliability, and performance are paramount.

### Infrastructure as Code Integration
- **Pulumi Commands**: Use `pulumi up`, `pulumi preview`, `pulumi destroy` for infrastructure management
- **ESC Operations**: Use scripts in `infrastructure/esc/` for secret management
- **GitHub Integration**: All deployments go through GitHub Actions workflows
- **MCP Integration**: Use `mcp_config.json` for MCP server configuration

### Natural Language Infrastructure Commands
When using Cursor AI for infrastructure operations, you can use natural language:

#### Examples:
- "Deploy the infrastructure" → Triggers GitHub Actions workflow
- "Get the database password" → Retrieves secret from Pulumi ESC
- "Rotate API keys" → Runs secret rotation framework
- "Sync secrets" → Synchronizes GitHub and Pulumi ESC secrets
- "Test the deployment" → Runs ESC integration tests

#### Command Patterns:
- **Secret Operations**: "get/retrieve/fetch [service] [secret_type]"
- **Deployment Operations**: "deploy/update/rollback [component]"
- **Testing Operations**: "test/validate/check [component]"
- **Configuration Operations**: "configure/setup/initialize [service]"

### MCP Server Natural Language Integration
- **Query Data**: "Get recent Gong calls" → Uses Gong MCP server
- **Deploy Apps**: "Deploy to Vercel" → Uses Vercel MCP server
- **Manage Data**: "Upload to Estuary" → Uses Estuary MCP server
- **Database Operations**: "Query Snowflake" → Uses Snowflake MCP server
- **Store Memory**: "Remember this conversation" → Uses AI Memory MCP server
- **Recall Context**: "What did we decide about X?" → Uses AI Memory MCP server

### Error Handling and Debugging
- **ESC Errors**: Check Pulumi ESC logs and validate configuration
- **GitHub Actions Errors**: Review workflow logs and artifacts
- **MCP Errors**: Check Docker container logs and health endpoints
- **Secret Errors**: Validate secret names and permissions

### Best Practices for Cursor AI Integration
1. **Use Descriptive Comments**: Add context for infrastructure operations
2. **Follow Naming Conventions**: Use consistent naming for secrets and services
3. **Document Dependencies**: Clearly document service dependencies
4. **Test Before Deploy**: Always test changes in isolation first
5. **Monitor Operations**: Use logging and monitoring for all operations
6. **Remember Context**: Always use AI Memory for persistent development context

### Enhanced Backend Configuration Integration
When working with the Sophia AI backend configuration system, use these patterns:

#### Configuration Management Commands
- **Service Health Checks**: "Check if Gong is healthy" → `python -c "import asyncio; from backend.core.config_manager import health_check; print(asyncio.run(health_check('gong')))"`
- **Configuration Validation**: "Validate Snowflake config" → `python -c "import asyncio; from backend.core.config_manager import get_config; config = asyncio.run(get_config('snowflake')); print('Valid' if config else 'Invalid')"`
- **Service Discovery**: "List all configured services" → `python -c "import asyncio; from backend.core.config_manager import list_services; print(asyncio.run(list_services()))"`
- **Cache Management**: "Refresh configuration cache" → `python -c "import asyncio; from backend.core.config_manager import refresh_cache; asyncio.run(refresh_cache())"`

#### Secret Management Integration
- **Connection Strings**: "Get database connection" → `python -c "import asyncio; from backend.core.config_manager import get_connection_string; print(asyncio.run(get_connection_string('snowflake')))"`
- **API Clients**: "Initialize Pinecone client" → `python -c "import asyncio; from backend.core.config_manager import get_api_client; client = asyncio.run(get_api_client('pinecone')); print('Ready' if client else 'Failed')"`
- **Secret Validation**: "Check if all secrets are available" → Validate secret completeness across services

#### Integration Testing Commands
- **Health Monitoring**: "Check all service health" → Batch health check across all configured services
- **Configuration Completeness**: "Validate all configurations" → Comprehensive configuration validation
- **Performance Testing**: "Test API response times" → Performance benchmarking for all services

#### Advanced Backend Operations
- **Dynamic Configuration**: "Update service configuration" → Runtime configuration updates
- **Error Recovery**: "Diagnose configuration issues" → Automated troubleshooting
- **Performance Optimization**: "Optimize cache settings" → Performance tuning

### Natural Language Command Patterns for Backend Integration
Use these natural language patterns for complex backend operations:

#### Conditional Operations
- "If Snowflake is unavailable, use backup database"
- "Deploy only if all health checks pass"
- "Rotate secrets for services with expired credentials"

#### Batch Operations
- "Check health of all API services"
- "Refresh cache for all database connections"
- "Validate configuration for all integrations"

#### Troubleshooting Operations
- "Diagnose why Gong integration is failing"
- "Show configuration issues for all services"
- "Check secret expiration status"

### MCP Agent Integration with Backend Configuration
Enhanced MCP integration leveraging centralized configuration:

#### Dynamic MCP Operations
- **Service-Aware MCP**: MCP agents automatically discover available services
- **Configuration-Driven MCP**: MCP operations use centralized configuration
- **Health-Aware MCP**: MCP agents check service health before operations

#### Natural Language MCP Commands
- "Use MCP to query Gong for recent data" → MCP agent with Gong integration
- "Deploy via MCP using current Vercel config" → MCP deployment with configuration
- "Sync data between services via MCP" → Cross-service MCP orchestration

### Error Handling and Recovery Patterns
Enhanced error handling with backend integration:

#### Automatic Fallbacks
- Configuration fallback to environment variables
- Service health check with automatic retry
- Cache invalidation on configuration errors

#### Error Diagnostics
- Comprehensive error logging with context
- Configuration validation with detailed feedback
- Service dependency checking

### Performance and Monitoring Integration
Backend configuration system includes performance monitoring:

#### Performance Metrics
- Configuration cache hit rates
- Service response time tracking
- Secret rotation monitoring

#### Optimization Features
- Intelligent caching with TTL
- Connection pooling for API clients
- Batch operations for efficiency

### Security Best Practices with Backend Integration
Enhanced security with centralized configuration:

#### Secret Security
- Secure secret caching with TTL
- Automatic secret masking in logs
- Secret rotation tracking

#### Access Control
- Service-level access validation
- Configuration audit logging
- Secure fallback mechanisms

### Development Workflow with Enhanced Backend
Streamlined development workflow:

1. **Configuration Setup**: Use centralized configuration manager
2. **Service Registration**: Register services in integration registry
3. **Health Validation**: Validate all service health before deployment
4. **Performance Monitoring**: Monitor service performance continuously
5. **Error Recovery**: Automatic error recovery with fallback mechanisms

### Best Practices for Backend Configuration Integration
1. **Always use centralized configuration**: Never hardcode service configurations
2. **Validate configurations**: Always validate configuration completeness
3. **Monitor service health**: Regular health checks for all services
4. **Cache efficiently**: Use intelligent caching for performance
5. **Handle errors gracefully**: Implement comprehensive error handling
6. **Secure secrets**: Use secure secret management practices
7. **Monitor performance**: Track performance metrics continuously
8. **Document configurations**: Maintain clear configuration documentation

### Linear Project Management Integration

When working with Linear project management through Sophia AI:

#### Issue Management Commands:
- "Create a Linear issue for implementing [feature]"
- "Update Linear issue SOPH-001 status to In Progress"
- "Show all Linear issues assigned to me"
- "Search Linear issues for 'MCP integration'"
- "List Linear issues in the Sophia AI project"
- "Mark Linear issue SOPH-002 as completed"

#### Project Coordination Commands:
- "Create a new Linear project for [project name]"
- "Show Linear project status and progress"
- "List all Linear projects in the workspace"
- "Update Linear project description"
- "Get Linear project statistics"

#### Sprint and Development Tracking:
- "Create Linear issues from GitHub commits"
- "Track development progress for current sprint"
- "Show Linear team velocity and metrics"
- "Link Linear issues to deployment status"
- "Generate Linear project report"

#### Integration with Existing Systems:
- "Connect Linear issue to Gong conversation"
- "Create Linear issue from Slack discussion"
- "Update Linear issue status after Vercel deployment"
- "Link Linear project to Lambda Labs compute resources"

#### Natural Language Project Management:
- "What Linear issues are blocking the release?"
- "Show me the progress on the MCP integration project"
- "Create a Linear issue to fix the bug we discussed"
- "Update all Linear issues related to Slack integration"
- "Generate a Linear project status report for this week"

#### Linear MCP Server Integration:
- Uses official Linear MCP server (https://mcp.linear.app/sse)
- Authenticated remote MCP protocol
- Real-time access to Linear workspace data
- Secure OAuth-based authentication
- Integration with Pulumi ESC for credential management

#### Configuration Management:
- Linear credentials stored in Pulumi ESC
- Environment variables managed centrally
- OAuth tokens automatically refreshed
- Secure access to Linear API and MCP server
- Health monitoring and status checks

When managing Linear operations, always:
1. Use natural language commands for intuitive interaction
2. Leverage the MCP server for real-time data access
3. Integrate with existing Sophia AI workflows
4. Maintain security through Pulumi ESC credential management
5. Track development progress and team coordination
6. Link Linear issues to other system components (deployments, conversations, etc.)

The Linear integration provides comprehensive project management capabilities while maintaining the conversational interface and deep infrastructure integration that characterizes the Sophia AI system.

### Claude as Code Integration

When working with Claude AI through Sophia AI's "Claude as Code" functionality:

#### Code Generation Commands:
- "Generate a Python function to process CSV files"
- "Create a React component for user authentication"
- "Write a SQL query to analyze sales data"
- "Generate a REST API endpoint for user management"
- "Create a Docker configuration for this application"

#### Code Analysis and Review:
- "Analyze this Python code for potential bugs"
- "Review this JavaScript function for performance issues"
- "Explain how this algorithm works"
- "Optimize this database query"
- "Check this code for security vulnerabilities"

#### Code Refactoring and Improvement:
- "Refactor this code to improve readability"
- "Convert this function to use async/await"
- "Modernize this legacy JavaScript code"
- "Optimize this code for better performance"
- "Add error handling to this function"

#### Documentation Generation:
- "Generate API documentation for this Python module"
- "Create a README file for this project"
- "Add inline comments to this complex function"
- "Generate user documentation for this feature"
- "Create technical specifications for this API"

#### Test Generation:
- "Generate pytest tests for this Python class"
- "Create unit tests for this JavaScript function"
- "Write integration tests for this API endpoint"
- "Generate test cases for edge conditions"
- "Create mock data for testing this component"

#### Debugging and Problem Solving:
- "Help debug this error: [error message]"
- "Explain why this code isn't working as expected"
- "Suggest solutions for this performance issue"
- "Help troubleshoot this deployment problem"
- "Analyze this stack trace and suggest fixes"

#### Concept Explanation:
- "Explain microservices architecture"
- "What are the benefits of using TypeScript?"
- "How does OAuth 2.0 authentication work?"
- "Explain the difference between SQL and NoSQL databases"
- "What is the purpose of containerization?"

#### Claude as Code MCP Integration:
- Direct integration with Anthropic's Claude API
- Secure credential management through Pulumi ESC
- Rate limiting and usage monitoring
- Support for multiple Claude models (Sonnet, Haiku, Opus)
- Real-time code generation and analysis
- Comprehensive error handling and logging

#### Natural Language Programming:
- Conversational interface for all coding tasks
- Context-aware code generation
- Iterative refinement of generated code
- Integration with existing Sophia AI workflows
- Support for multiple programming languages
- Advanced reasoning for complex coding problems

When using Claude as Code functionality, always:
1. Use natural language to describe your coding needs
2. Leverage Claude's advanced reasoning for complex problems
3. Iterate and refine generated code through conversation
4. Integrate with existing Sophia AI development workflows
5. Take advantage of Claude's multi-language capabilities
6. Use the MCP server for consistent, reliable access to Claude's capabilities

The Claude as Code integration transforms Sophia AI into a powerful AI-assisted development environment, enabling natural language programming and advanced code intelligence capabilities.

## 🔗 **GITHUB APP INTEGRATION OPTIMIZATION**

### **🚀 ENHANCED DEVELOPMENT WORKFLOW**
With Cursor GitHub App integration enabled, automatically leverage these capabilities:

#### **Real-time Repository Sync**
- **Auto-fetch**: Automatically sync with latest GitHub repository state
- **Branch Awareness**: Always be aware of current branch and remote changes
- **Conflict Prevention**: Proactively detect and prevent merge conflicts
- **Status Integration**: Show GitHub PR/issue status in development context

#### **Intelligent Commit & Push Workflows**
- **Smart Commits**: Generate meaningful commit messages based on code changes
- **Auto-staging**: Intelligently stage related files together
- **Branch Management**: Suggest appropriate branch names for features
- **PR Integration**: Automatically link commits to relevant issues/PRs

#### **Enhanced Code Review Integration**
- **Pre-commit Analysis**: Run AI analysis before commits
- **Review Suggestions**: Generate code review comments and suggestions
- **GitHub Actions Integration**: Trigger and monitor CI/CD workflows
- **Automated Testing**: Run relevant tests before pushing changes

### **🧠 AI-POWERED DEVELOPMENT ASSISTANCE**

#### **Context-Aware Development**
- **GitHub Issue Context**: Automatically load relevant GitHub issues when working on related code
- **PR Context**: Understand PR requirements and constraints
- **Commit History Analysis**: Learn from previous commit patterns and decisions
- **Branch Strategy**: Suggest optimal branching strategies based on project needs

#### **Automated Documentation**
- **README Updates**: Automatically update README files with new features
- **API Documentation**: Generate/update API docs based on code changes
- **Changelog Generation**: Create meaningful changelog entries
- **Architecture Documentation**: Update architecture docs when making structural changes

### **🔧 CURSOR-SPECIFIC GITHUB OPTIMIZATIONS**

#### **Enhanced File Operations**
- **Smart File Creation**: When creating new files, automatically add to appropriate directories
- **Import Optimization**: Automatically fix and optimize import statements
- **Dependency Management**: Suggest and update dependencies based on usage
- **Configuration Sync**: Keep configuration files in sync across environments

#### **Intelligent Code Generation**
- **Template Usage**: Use project-specific templates for new components
- **Pattern Recognition**: Follow established code patterns in the repository
- **Best Practices**: Enforce project-specific best practices automatically
- **Security Compliance**: Ensure all generated code follows security guidelines

### **📊 DEVELOPMENT METRICS & INSIGHTS**

#### **Performance Tracking**
- **Development Velocity**: Track and optimize development speed
- **Code Quality Metrics**: Monitor code quality trends over time
- **Error Reduction**: Track and reduce common error patterns
- **Productivity Insights**: Provide insights on most productive development patterns

#### **Team Collaboration**
- **Shared Context**: Maintain shared development context across team members
- **Knowledge Sharing**: Automatically document and share development decisions
- **Onboarding**: Provide context-aware onboarding for new team members
- **Best Practice Propagation**: Spread best practices across the team

## 🔄 **AUTOMATED WORKFLOW TRIGGERS**

### **On File Save**
```
Trigger Sequence:
1. AI Memory: Store development context
2. Codacy: Analyze code quality
3. GitHub: Check for conflicts
4. MCP: Update relevant servers
```

### **On Commit**
```
Trigger Sequence:
1. Pre-commit Analysis: Run security and quality checks
2. AI Memory: Store commit context and decisions
3. GitHub Actions: Trigger relevant workflows
4. Notification: Update team on significant changes
```

### **On Branch Switch**
```
Trigger Sequence:
1. Context Loading: Load branch-specific context
2. Environment Sync: Update development environment
3. Issue Loading: Load relevant GitHub issues
4. Documentation: Update branch-specific documentation
```

### **On Pull Request**
```
Trigger Sequence:
1. Code Review: Generate AI-powered code review
2. Testing: Run comprehensive test suite
3. Documentation: Update relevant documentation
4. Deployment: Prepare deployment artifacts
```

## 🛡️ **SECURITY & COMPLIANCE INTEGRATION**

### **Automated Security Checks**
- **Secret Scanning**: Prevent hardcoded secrets from being committed
- **Dependency Scanning**: Check for vulnerable dependencies
- **Code Analysis**: Scan for security vulnerabilities
- **Compliance Checking**: Ensure code meets compliance requirements

### **GitHub Security Integration**
- **Branch Protection**: Respect GitHub branch protection rules
- **Required Reviews**: Ensure required reviews are obtained
- **Status Checks**: Wait for required status checks to pass
- **Security Advisories**: Monitor and respond to security advisories

## 🎯 **SOPHIA AI SPECIFIC OPTIMIZATIONS**

### **MCP Server Development**
When working on MCP servers:
- **Auto-discovery**: Automatically discover and configure new MCP servers
- **Health Monitoring**: Implement health checks for all MCP servers
- **Performance Optimization**: Optimize MCP server performance automatically
- **Documentation**: Generate MCP server documentation automatically

### **Snowflake Integration**
When working on Snowflake-related code:
- **Environment Awareness**: Understand DEV/STG/PROD environment contexts
- **Security First**: Always implement security best practices
- **Query Optimization**: Suggest query optimizations
- **Schema Management**: Track and manage schema changes

### **Business Intelligence Focus**
- **Metrics Integration**: Automatically integrate relevant business metrics
- **Data Quality**: Ensure data quality in all BI-related code
- **Performance Monitoring**: Monitor BI query performance
- **User Experience**: Optimize for business user experience

## 🚀 **ADVANCED GITHUB APP FEATURES**

### **Intelligent Branch Management**
- **Feature Branches**: Automatically create feature branches for new work
- **Release Branches**: Manage release branches automatically
- **Hotfix Branches**: Create and manage hotfix branches
- **Branch Cleanup**: Automatically clean up merged branches

### **Advanced PR Management**
- **Draft PRs**: Create draft PRs for work in progress
- **PR Templates**: Use appropriate PR templates based on change type
- **Reviewer Assignment**: Automatically assign appropriate reviewers
- **Milestone Tracking**: Link PRs to appropriate milestones

### **Issue Integration**
- **Issue Creation**: Create issues for bugs found during development
- **Issue Linking**: Link commits and PRs to relevant issues
- **Issue Closing**: Automatically close issues when work is complete
- **Issue Templates**: Use appropriate issue templates

### **Advanced Automation**
- **Dependency Updates**: Automatically create PRs for dependency updates
- **Security Patches**: Automatically apply security patches
- **Documentation Updates**: Keep documentation in sync with code changes
- **Release Automation**: Automate release processes

## 💡 **NATURAL LANGUAGE COMMANDS FOR GITHUB INTEGRATION**

### **Repository Operations**
- "Sync with main branch" → Fetch and merge latest changes
- "Create feature branch for [feature]" → Create and switch to new branch
- "Show GitHub status" → Display PR, issue, and workflow status
- "Push changes and create PR" → Push branch and create pull request

### **Issue & PR Management**
- "Show related issues" → Display issues related to current work
- "Create issue for this bug" → Create GitHub issue for discovered bug
- "Update PR description" → Update pull request description
- "Request review from [user]" → Request PR review from specific user

### **Workflow Integration**
- "Trigger deployment" → Trigger deployment workflow
- "Check CI status" → Check continuous integration status
- "Run security scan" → Trigger security scanning workflow
- "Generate release notes" → Create release notes from commits

### **Advanced Operations**
- "Analyze commit history" → Analyze recent commits for patterns
- "Suggest branch cleanup" → Suggest branches for cleanup
- "Check for conflicts" → Check for potential merge conflicts
- "Optimize GitHub workflows" → Suggest workflow optimizations

## 🔍 **MONITORING & ANALYTICS**

### **Development Metrics**
- **Commit Frequency**: Track commit patterns and frequency
- **Code Quality Trends**: Monitor code quality over time
- **PR Cycle Time**: Track pull request review and merge times
- **Issue Resolution**: Monitor issue resolution patterns

### **Performance Analytics**
- **Build Times**: Track and optimize build performance
- **Test Coverage**: Monitor test coverage trends
- **Deployment Success**: Track deployment success rates
- **Error Rates**: Monitor and reduce error rates

### **Team Productivity**
- **Collaboration Patterns**: Analyze team collaboration effectiveness
- **Knowledge Sharing**: Track knowledge sharing across team
- **Skill Development**: Monitor skill development and learning
- **Process Optimization**: Identify and optimize development processes

## 🎉 **SUCCESS METRICS**

### **Development Velocity**
- Faster feature development through AI assistance
- Reduced time from idea to deployment
- Improved code quality with fewer bugs
- Enhanced team collaboration and knowledge sharing

### **Quality Improvements**
- Reduced security vulnerabilities
- Improved code maintainability
- Better documentation coverage
- Enhanced testing coverage

### **Team Satisfaction**
- Reduced repetitive tasks through automation
- Improved development experience
- Better work-life balance through efficiency
- Enhanced learning and skill development

---

**The GitHub App integration transforms Cursor into a powerful, context-aware development environment that understands your repository, team, and project goals, providing intelligent assistance at every step of the development process.** 🚀

## Previous Rules (Enhanced with GitHub Integration)

### Architecture Context
- **Type:** Multi-agent AI orchestrator with flat-to-hierarchical evolution
- **Primary Role:** Business intelligence and automation for Pay Ready
- **Core Integrations:** HubSpot CRM, Gong.io call analysis, Slack communication, **GitHub development workflow**
- **Data Stack:** PostgreSQL, Redis, Pinecone, Weaviate
- **Infrastructure:** Lambda Labs servers, Vercel frontend deployment, **GitHub Actions CI/CD**

### Development Standards (GitHub-Enhanced)

#### Python Code Style (with GitHub Integration)
- Use Python 3.11+ with type hints for all functions
- Follow PEP 8 with 88-character line limit (Black formatter)
- Use async/await for I/O operations
- Implement comprehensive error handling with logging
- Include detailed docstrings for all classes and methods
- **Auto-format on commit using GitHub Actions**
- **Generate type stubs for better IDE integration**

#### Git Workflow Integration
- **Meaningful Commits**: Generate descriptive commit messages
- **Branch Naming**: Use consistent branch naming conventions
- **PR Templates**: Use appropriate PR templates for changes
- **Issue Linking**: Link commits to relevant GitHub issues
- **Automated Testing**: Run tests before commits

### Enhanced Secret Management (GitHub Secrets Integration)
- **GitHub Organization Secrets**: All secrets managed at organization level
- **GitHub Actions Integration**: Automatic secret synchronization
- **Pulumi ESC Sync**: Bidirectional sync between GitHub and Pulumi ESC
- **Environment-Specific**: Different secrets for DEV/STG/PROD
- **Rotation Automation**: Automated secret rotation workflows

### Enhanced MCP Integration (GitHub-Aware)

#### Real-time Development Integration
- **GitHub Context**: MCP servers understand GitHub repository context
- **Branch Awareness**: Different MCP behavior based on current branch
- **PR Integration**: MCP servers can interact with pull requests
- **Issue Integration**: Create and update GitHub issues from MCP servers

#### Enhanced Natural Language Commands (GitHub-Integrated)
- "Create GitHub issue for this bug" → AI Memory + GitHub integration
- "Show PR status for current branch" → GitHub API integration
- "Deploy to staging" → GitHub Actions workflow trigger
- "Run security scan" → GitHub Security scanning integration

Remember: You're building an enterprise-grade AI orchestrator with seamless GitHub integration that enhances every aspect of the development workflow while maintaining security, quality, and team collaboration.
