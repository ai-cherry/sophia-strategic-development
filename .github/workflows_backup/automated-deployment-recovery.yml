name: Automated Deployment Recovery

on:
  workflow_dispatch:
    inputs:
      recovery_type:
        description: 'Type of recovery to run'
        required: true
        default: 'full'
        type: choice
        options:
          - full
          - frontend-only
          - backend-only
          - status-check
      
  # Trigger on deployment failure
  workflow_run:
    workflows: ["Deploy to Production", "CI/CD Pipeline"]
    types:
      - completed

env:
  NODE_VERSION: '18'
  PYTHON_VERSION: '3.11'

jobs:
  automated-recovery:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    # Only run on manual trigger or if deployment workflow failed
    if: ${{ github.event_name == 'workflow_dispatch' || github.event.workflow_run.conclusion == 'failure' }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json
        
    - name: Install Python dependencies
      run: |
        python -m pip install --upgrade pip
        pip install requests
        
    - name: Clear npm cache
      run: |
        npm cache clean --force
        
    - name: Frontend Recovery (Frontend-only or Full)
      if: ${{ github.event.inputs.recovery_type == 'frontend-only' || github.event.inputs.recovery_type == 'full' || github.event.inputs.recovery_type == '' }}
      run: |
        cd frontend
        rm -rf node_modules package-lock.json
        npm cache clean --force
        npm install --no-package-lock
        npm audit fix --force || true
        
    - name: Backend Recovery (Backend-only or Full)
      if: ${{ github.event.inputs.recovery_type == 'backend-only' || github.event.inputs.recovery_type == 'full' || github.event.inputs.recovery_type == '' }}
      run: |
        pip install \
          sqlalchemy \
          pyjwt \
          passlib[bcrypt] \
          aiofiles \
          python-multipart \
          email-validator \
          qdrant-client \
          uvicorn[standard] \
          fastapi \
          redis \
          psycopg2-binary \
          asyncpg
          
    - name: Run Automated Recovery Script
      id: recovery
      run: |
        python scripts/automated_deployment_recovery.py
        echo "recovery_status=$?" >> $GITHUB_OUTPUT
        
    - name: Generate Status Report
      run: |
        python scripts/automated_deployment_recovery.py --status-only > deployment_status.json
        
    - name: Upload Recovery Logs
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: deployment-recovery-logs
        path: |
          deployment_recovery.log
          deployment_recovery_report.json
          deployment_status.json
          backend.log
          frontend.log
          mcp.log
        retention-days: 30
        
    - name: Create GitHub Issue on Failure
      if: ${{ steps.recovery.outputs.recovery_status != '0' }}
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          let reportContent = 'Recovery report not available';
          
          try {
            const report = JSON.parse(fs.readFileSync('deployment_recovery_report.json', 'utf8'));
            reportContent = `
          ## 🚨 Automated Deployment Recovery Failed
          
          **Timestamp:** ${new Date(report.timestamp * 1000).toISOString()}
          
          ### Service Status
          ${Object.entries(report.services).map(([service, healthy]) => 
            `- ${service}: ${healthy ? '✅ Healthy' : '❌ Unhealthy'}`
          ).join('\n')}
          
          ### Recommendations
          ${report.recommendations.map(rec => `- ${rec}`).join('\n')}
          
          ### Workflow Information
          - **Run ID:** ${{ github.run_id }}
          - **Trigger:** ${{ github.event_name }}
          - **Recovery Type:** ${{ github.event.inputs.recovery_type || 'automatic' }}
          
          Please investigate and resolve the issues manually.
          `;
          } catch (e) {
            reportContent = `
          ## 🚨 Automated Deployment Recovery Failed
          
          Recovery failed and report could not be generated.
          
          **Error:** ${e.message}
          **Run ID:** ${{ github.run_id }}
          **Trigger:** ${{ github.event_name }}
          `;
          }
          
          github.rest.issues.create({
            owner: context.repo.owner,
            repo: context.repo.repo,
            title: `🚨 Deployment Recovery Failed - ${new Date().toISOString().split('T')[0]}`,
            body: reportContent,
            labels: ['deployment', 'recovery-failed', 'urgent']
          });
          
    - name: Slack Notification
      if: always()
      uses: 8398a7/action-slack@v3
      with:
        status: ${{ steps.recovery.outputs.recovery_status == '0' && 'success' || 'failure' }}
        text: |
          🔧 Deployment Recovery ${{ steps.recovery.outputs.recovery_status == '0' && 'Completed Successfully' || 'Failed' }}
          
          Trigger: ${{ github.event_name }}
          Recovery Type: ${{ github.event.inputs.recovery_type || 'automatic' }}
          Run: ${{ github.run_id }}
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  health-monitoring:
    needs: automated-recovery
    runs-on: ubuntu-latest
    if: always()
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        
    - name: Install monitoring dependencies
      run: |
        pip install requests
        
    - name: Extended Health Monitoring
      run: |
        python -c "
        import requests
        import time
        import json
        
        services = {
            'backend': 'https://api.sophia-intel.ai/health',
            'frontend': 'https://app.sophia-intel.ai',
            'docs': 'https://sophia-intel.ai/docs'
        }
        
        results = {}
        for service, url in services.items():
            try:
                response = requests.get(url, timeout=10)
                results[service] = {
                    'status': response.status_code,
                    'healthy': response.status_code == 200,
                    'response_time': response.elapsed.total_seconds()
                }
            except Exception as e:
                results[service] = {
                    'status': 'error',
                    'healthy': False,
                    'error': str(e)
                }
        
        print(json.dumps(results, indent=2))
        
        # Fail the job if critical services are down
        critical_services = ['backend', 'frontend']
        unhealthy_critical = [s for s in critical_services if not results.get(s, {}).get('healthy', False)]
        
        if unhealthy_critical:
            print(f'CRITICAL: Unhealthy services: {unhealthy_critical}')
            exit(1)
        else:
            print('✅ All critical services healthy')
        "
        
    - name: Update Status Badge
      if: always()
      run: |
        # Create a simple status badge update
        echo "Deployment Status: ${{ job.status }}" > deployment_status.txt 