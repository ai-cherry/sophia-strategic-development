name: 🚀 Sophia Unified Deployment

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        type: choice
        options:
          - production
          - staging
          - development
        default: production
      deploy_backend:
        description: 'Deploy backend services'
        type: boolean
        default: true
      deploy_mcp:
        description: 'Deploy MCP servers'
        type: boolean
        default: true
      deploy_frontend:
        description: 'Deploy frontend'
        type: boolean
        default: true
      deploy_monitoring:
        description: 'Deploy monitoring stack'
        type: boolean
        default: false

env:
  DOCKER_REGISTRY: scoobyjava15
  PULUMI_ORG: scoobyjava-org
  # Dynamic environment based on branch or input
  ENVIRONMENT: ${{ github.event.inputs.environment || (github.ref == 'refs/heads/main' && 'production' || 'staging') }}

jobs:
  # 1. Quality Gate - Always run
  quality-gate:
    name: Quality Gate
    uses: ./.github/workflows/reusable-quality-gate.yml

  # 2. Build and Push Images
  build:
    name: Build Images
    needs: quality-gate
    # Continue even if quality gate has warnings
    if: always() && needs.quality-gate.result != 'failure'
    uses: ./.github/workflows/reusable-build-and-push.yml
    with:
      backend: ${{ github.event.inputs.deploy_backend != 'false' }}
      mcp_servers: ${{ github.event.inputs.deploy_mcp != 'false' }}
      registry: scoobyjava15
    secrets: inherit

  # 3. Infrastructure Deployment (Pulumi)
  infrastructure:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    # Only deploy infra on main branch or manual trigger
    if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
    outputs:
      instance_ip: ${{ steps.pulumi.outputs.instance_ip }}
    steps:
      - uses: actions/checkout@v4

      - name: Setup Pulumi
        uses: pulumi/actions@v6
        with:
          command: preview
          stack-name: ${{ env.PULUMI_ORG }}/sophia-ai-${{ env.ENVIRONMENT }}
          work-dir: infrastructure/
        env:
          PULUMI_ACCESS_TOKEN: ${{ secrets.PULUMI_ACCESS_TOKEN }}

      - name: Deploy Infrastructure
        id: pulumi
        if: github.event_name != 'pull_request'
        uses: pulumi/actions@v6
        with:
          command: up
          stack-name: ${{ env.PULUMI_ORG }}/sophia-ai-${{ env.ENVIRONMENT }}
          work-dir: infrastructure/
        env:
          PULUMI_ACCESS_TOKEN: ${{ secrets.PULUMI_ACCESS_TOKEN }}

      - name: Get outputs
        id: outputs
        run: |
          cd infrastructure
          INSTANCE_IP=$(pulumi stack output lambdaLabsInstanceIp --stack ${{ env.PULUMI_ORG }}/sophia-ai-${{ env.ENVIRONMENT }} || echo "192.222.51.122")
          echo "instance_ip=$INSTANCE_IP" >> $GITHUB_OUTPUT

  # 4. Deploy to Docker Swarm
  deploy-stack:
    name: Deploy Stack
    needs: [build, infrastructure]
    if: |
      always() &&
      needs.build.result == 'success' &&
      (github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch')
    uses: ./.github/workflows/reusable-swarm-deploy.yml
    with:
      compose_file: docker-compose.unified.yml
      environment: ${{ env.ENVIRONMENT }}
      stack_name: sophia-ai
      host: ${{ needs.infrastructure.outputs.instance_ip || '192.222.51.122' }}
    secrets: inherit

  # 5. Deploy Frontend to Vercel
  deploy-frontend:
    name: Deploy Frontend
    needs: deploy-stack
    if: |
      always() &&
      needs.deploy-stack.result == 'success' &&
      github.event.inputs.deploy_frontend != 'false'
    uses: ./.github/workflows/reusable-vercel-deploy.yml
    with:
      environment: ${{ env.ENVIRONMENT }}
      project_name: sophia-ai-unified-dashboard
    secrets: inherit

  # 6. Validation and Health Checks
  validate:
    name: Validate Deployment
    runs-on: ubuntu-latest
    needs: [deploy-stack, deploy-frontend]
    if: always()
    steps:
      - uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install dependencies
        run: pip install requests aiohttp

      - name: Download deployment info
        uses: actions/download-artifact@v4
        with:
          name: deployment-info
          path: .

      - name: Run validation tests
        run: |
          # Get deployment details
          HOST=$(jq -r '.host' deployment-info.json)

          # Create validation script
          cat > validate.py << 'EOF'
          import asyncio
          import aiohttp
          import json
          import sys
          from datetime import datetime

          async def check_service(session, name, url):
              try:
                  async with session.get(url, timeout=10) as resp:
                      return {
                          "name": name,
                          "url": url,
                          "status": resp.status,
                          "healthy": resp.status == 200,
                          "response_time": resp.headers.get('X-Response-Time', 'N/A')
                      }
              except Exception as e:
                  return {
                      "name": name,
                      "url": url,
                      "status": 0,
                      "healthy": False,
                      "error": str(e)
                  }

          async def main():
              host = sys.argv[1]

              services = [
                  ("Backend API", f"http://{host}:8000/api/health"),
                  ("MCP Gateway", f"http://{host}:8080/health"),
                  ("Prometheus", f"http://{host}:9090/-/healthy"),
                  ("Grafana", f"http://{host}:3000/api/health"),
              ]

              async with aiohttp.ClientSession() as session:
                  results = await asyncio.gather(*[
                      check_service(session, name, url)
                      for name, url in services
                  ])

              # Generate report
              healthy_count = sum(1 for r in results if r['healthy'])
              total_count = len(results)

              print(f"## Deployment Validation Report")
              print(f"\nDate: {datetime.utcnow().isoformat()}Z")
              print(f"Host: {host}")
              print(f"Overall Health: {healthy_count}/{total_count} services healthy")
              print("\n### Service Status:")

              for result in results:
                  status = "✅" if result['healthy'] else "❌"
                  print(f"{status} **{result['name']}**: {result.get('error', 'OK')}")

              # Exit with error if not all healthy
              if healthy_count < total_count:
                  sys.exit(1)

          if __name__ == "__main__":
              asyncio.run(main())
          EOF

          python validate.py $HOST | tee validation-report.md

      - name: Update deployment summary
        run: |
          cat validation-report.md >> $GITHUB_STEP_SUMMARY

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Deployment Links" >> $GITHUB_STEP_SUMMARY
          echo "- 🌐 [Frontend](https://app.sophia-intel.ai)" >> $GITHUB_STEP_SUMMARY
          echo "- 🔧 [API Docs](http://$HOST:8000/docs)" >> $GITHUB_STEP_SUMMARY
          echo "- 📊 [Grafana](http://$HOST:3000)" >> $GITHUB_STEP_SUMMARY
          echo "- 📈 [Prometheus](http://$HOST:9090)" >> $GITHUB_STEP_SUMMARY

      - name: Upload validation report
        uses: actions/upload-artifact@v4
        with:
          name: validation-report
          path: validation-report.md

  # 7. Notification
  notify:
    name: Notify Status
    runs-on: ubuntu-latest
    needs: [validate]
    if: always()
    steps:
      - name: Determine status
        id: status
        run: |
          if [ "${{ needs.validate.result }}" = "success" ]; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "emoji=✅" >> $GITHUB_OUTPUT
            echo "message=Deployment successful!" >> $GITHUB_OUTPUT
          else
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "emoji=❌" >> $GITHUB_OUTPUT
            echo "message=Deployment failed!" >> $GITHUB_OUTPUT
          fi

      - name: Send Slack notification
        if: env.SLACK_WEBHOOK != ''
        env:
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
        run: |
          curl -X POST $SLACK_WEBHOOK \
            -H 'Content-Type: application/json' \
            -d '{
              "text": "${{ steps.status.outputs.emoji }} Sophia AI Deployment ${{ steps.status.outputs.message }}",
              "attachments": [{
                "color": "${{ steps.status.outputs.status == 'success' && 'good' || 'danger' }}",
                "fields": [
                  {"title": "Environment", "value": "'${{ env.ENVIRONMENT }}'", "short": true},
                  {"title": "Commit", "value": "'${{ github.sha }}'", "short": true},
                  {"title": "Actor", "value": "'${{ github.actor }}'", "short": true},
                  {"title": "Workflow", "value": "'${{ github.workflow }}'", "short": true}
                ]
              }]
            }'
