name: Deploy Sophia AI Platform
on:
  push:
    branches: [main, develop]
    paths:
      - 'backend/**'
      - 'infrastructure/**'
      - 'kubernetes/**'
      - 'docker-compose*.yml'
      - 'Dockerfile*'
      - '.github/workflows/deploy-sophia-platform.yml'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options: ['dev', 'staging', 'prod']
      force_deploy:
        description: 'Force deployment even if no changes detected'
        required: false
        default: false
        type: boolean
      skip_tests:
        description: 'Skip test suite (emergency deployments only)'
        required: false
        default: false
        type: boolean

env:
  PULUMI_ORG: scoobyjava-org
  PULUMI_STACK_PREFIX: sophia-ai-platform
  DOCKER_REGISTRY: registry.digitalocean.com/sophia-ai
  KUBERNETES_NAMESPACE: sophia-ai

# OIDC permissions for GitHub Actions
permissions:
  id-token: write      # Required for OIDC authentication
  contents: read       # Required for checkout
  actions: read        # Required for workflow access
  packages: write      # Required for Docker registry access
  deployments: write   # Required for deployment status
  statuses: write      # Required for commit status

jobs:
  # Job 1: Determine deployment environment and validate changes
  detect-environment:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.env-detect.outputs.environment }}
      should_deploy: ${{ steps.change-detect.outputs.should_deploy }}
      stack_name: ${{ steps.env-detect.outputs.stack_name }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Detect environment
        id: env-detect
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            ENVIRONMENT="${{ github.event.inputs.environment }}"
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            ENVIRONMENT="prod"
          elif [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then
            ENVIRONMENT="staging"
          else
            ENVIRONMENT="dev"
          fi
          
          STACK_NAME="${PULUMI_STACK_PREFIX}-${ENVIRONMENT}"
          
          echo "environment=${ENVIRONMENT}" >> $GITHUB_OUTPUT
          echo "stack_name=${STACK_NAME}" >> $GITHUB_OUTPUT
          echo "ðŸŽ¯ Detected environment: ${ENVIRONMENT}"
          echo "ðŸ“¦ Stack name: ${STACK_NAME}"

      - name: Detect changes
        id: change-detect
        run: |
          if [[ "${{ github.event.inputs.force_deploy }}" == "true" ]]; then
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "ðŸš€ Force deployment requested"
          else
            # Check for relevant changes
            CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD)
            if echo "$CHANGED_FILES" | grep -E "(backend/|infrastructure/|kubernetes/|docker-compose|Dockerfile)" > /dev/null; then
              echo "should_deploy=true" >> $GITHUB_OUTPUT
              echo "ðŸ“ Relevant changes detected"
            else
              echo "should_deploy=false" >> $GITHUB_OUTPUT
              echo "â­ï¸ No deployment changes detected"
            fi
          fi

  # Job 2: Run tests and validation
  test-and-validate:
    runs-on: ubuntu-latest
    needs: detect-environment
    if: needs.detect-environment.outputs.should_deploy == 'true'
    environment: ${{ needs.detect-environment.outputs.environment }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install -r requirements-dev.txt

      - name: Configure Pulumi ESC
        run: |
          # Install Pulumi CLI
          curl -fsSL https://get.pulumi.com | sh
          echo "$HOME/.pulumi/bin" >> $GITHUB_PATH
          
          # Set ESC environment
          export PULUMI_CONFIG_PASSPHRASE=""
          export PULUMI_STACK="${{ needs.detect-environment.outputs.stack_name }}"
          
          echo "ðŸ” Configured Pulumi ESC for stack: ${PULUMI_STACK}"

      - name: Run syntax validation
        run: |
          echo "ðŸ” Running syntax validation..."
          python -m py_compile backend/**/*.py
          echo "âœ… Syntax validation passed"

      - name: Run type checking
        run: |
          echo "ðŸ” Running type checking..."
          python -m mypy backend/ --ignore-missing-imports || true
          echo "âœ… Type checking completed"

      - name: Run unit tests
        if: github.event.inputs.skip_tests != 'true'
        run: |
          echo "ðŸ§ª Running unit tests..."
          python -m pytest tests/ -v --tb=short
          echo "âœ… Unit tests passed"

      - name: Run integration tests
        if: github.event.inputs.skip_tests != 'true' && needs.detect-environment.outputs.environment != 'prod'
        env:
          PULUMI_STACK: ${{ needs.detect-environment.outputs.stack_name }}
        run: |
          echo "ðŸ”— Running integration tests..."
          python -m pytest tests/integration/ -v --tb=short
          echo "âœ… Integration tests passed"

      - name: Validate Kubernetes manifests
        run: |
          echo "ðŸ” Validating Kubernetes manifests..."
          find infrastructure/kubernetes -name "*.yaml" -exec kubectl apply --dry-run=client --validate=true -f {} \;
          echo "âœ… Kubernetes manifest validation passed"

  # Job 3: Build and push Docker images
  build-and-push:
    runs-on: ubuntu-latest
    needs: [detect-environment, test-and-validate]
    if: needs.detect-environment.outputs.should_deploy == 'true'
    environment: ${{ needs.detect-environment.outputs.environment }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure OIDC for Docker Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.DOCKER_REGISTRY }}
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push webhook server
        uses: docker/build-push-action@v5
        with:
          context: .
          file: Dockerfile.gong-webhook
          push: true
          tags: |
            ${{ env.DOCKER_REGISTRY }}/gong-webhook-server:${{ github.sha }}
            ${{ env.DOCKER_REGISTRY }}/gong-webhook-server:${{ needs.detect-environment.outputs.environment }}
            ${{ env.DOCKER_REGISTRY }}/gong-webhook-server:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            ENVIRONMENT=${{ needs.detect-environment.outputs.environment }}
            BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
            VCS_REF=${{ github.sha }}

      - name: Build and push main backend
        uses: docker/build-push-action@v5
        with:
          context: .
          file: Dockerfile
          push: true
          tags: |
            ${{ env.DOCKER_REGISTRY }}/sophia-backend:${{ github.sha }}
            ${{ env.DOCKER_REGISTRY }}/sophia-backend:${{ needs.detect-environment.outputs.environment }}
            ${{ env.DOCKER_REGISTRY }}/sophia-backend:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            ENVIRONMENT=${{ needs.detect-environment.outputs.environment }}
            BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
            VCS_REF=${{ github.sha }}

      - name: Build and push MCP gateway
        uses: docker/build-push-action@v5
        with:
          context: ./mcp-gateway
          file: ./mcp-gateway/Dockerfile
          push: true
          tags: |
            ${{ env.DOCKER_REGISTRY }}/mcp-gateway:${{ github.sha }}
            ${{ env.DOCKER_REGISTRY }}/mcp-gateway:${{ needs.detect-environment.outputs.environment }}
            ${{ env.DOCKER_REGISTRY }}/mcp-gateway:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # Job 4: Deploy infrastructure with Pulumi
  deploy-infrastructure:
    runs-on: ubuntu-latest
    needs: [detect-environment, test-and-validate, build-and-push]
    if: needs.detect-environment.outputs.should_deploy == 'true'
    environment: ${{ needs.detect-environment.outputs.environment }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure OIDC for AWS
        if: env.AWS_OIDC_ROLE_ARN
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN }}
          aws-region: us-east-1
          role-session-name: GitHubActions-${{ github.sha }}

      - name: Configure OIDC for Azure
        if: env.AZURE_OIDC_CLIENT_ID
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_OIDC_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install Pulumi CLI
        run: |
          curl -fsSL https://get.pulumi.com | sh
          echo "$HOME/.pulumi/bin" >> $GITHUB_PATH

      - name: Install Pulumi dependencies
        working-directory: infrastructure
        run: |
          pip install -r requirements.txt

      - name: Configure Pulumi ESC
        env:
          PULUMI_ACCESS_TOKEN: ${{ secrets.PULUMI_ACCESS_TOKEN }}
          PULUMI_CONFIG_PASSPHRASE: ""
        run: |
          pulumi login
          pulumi stack select ${{ needs.detect-environment.outputs.stack_name }} || pulumi stack init ${{ needs.detect-environment.outputs.stack_name }}
          
          # Set ESC environment
          pulumi config set --path "environment" "scoobyjava-org/default/${{ needs.detect-environment.outputs.stack_name }}"
          
          echo "ðŸ” Configured Pulumi ESC for stack: ${{ needs.detect-environment.outputs.stack_name }}"

      - name: Preview infrastructure changes
        working-directory: infrastructure
        env:
          PULUMI_ACCESS_TOKEN: ${{ secrets.PULUMI_ACCESS_TOKEN }}
        run: |
          echo "ðŸ” Previewing infrastructure changes..."
          pulumi preview --diff --suppress-outputs
          echo "âœ… Infrastructure preview completed"

      - name: Deploy infrastructure
        working-directory: infrastructure
        env:
          PULUMI_ACCESS_TOKEN: ${{ secrets.PULUMI_ACCESS_TOKEN }}
        run: |
          echo "ðŸš€ Deploying infrastructure..."
          pulumi up --yes --suppress-outputs
          echo "âœ… Infrastructure deployment completed"

      - name: Export stack outputs
        working-directory: infrastructure
        env:
          PULUMI_ACCESS_TOKEN: ${{ secrets.PULUMI_ACCESS_TOKEN }}
        run: |
          echo "ðŸ“‹ Exporting stack outputs..."
          pulumi stack output --json > stack-outputs.json
          cat stack-outputs.json
          
          # Make outputs available to subsequent jobs
          echo "KUBECONFIG_DATA=$(pulumi stack output kubeconfig --show-secrets)" >> $GITHUB_ENV
          echo "CLUSTER_ENDPOINT=$(pulumi stack output cluster-endpoint)" >> $GITHUB_ENV

  # Job 5: Deploy to Kubernetes
  deploy-kubernetes:
    runs-on: ubuntu-latest
    needs: [detect-environment, deploy-infrastructure]
    if: needs.detect-environment.outputs.should_deploy == 'true'
    environment: ${{ needs.detect-environment.outputs.environment }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure kubectl
        run: |
          mkdir -p $HOME/.kube
          echo "${{ env.KUBECONFIG_DATA }}" | base64 -d > $HOME/.kube/config
          chmod 600 $HOME/.kube/config

      - name: Verify cluster connection
        run: |
          kubectl cluster-info
          kubectl get nodes

      - name: Create namespace if not exists
        run: |
          kubectl create namespace ${{ env.KUBERNETES_NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy Kubernetes secrets
        run: |
          echo "ðŸ” Deploying Kubernetes secrets..."
          
          # Apply secret manifests with ESC integration
          find infrastructure/kubernetes -name "*secret*.yaml" -exec kubectl apply -f {} \;
          
          echo "âœ… Kubernetes secrets deployed"

      - name: Deploy Kubernetes manifests
        run: |
          echo "ðŸš€ Deploying Kubernetes manifests..."
          
          # Update image tags with current SHA
          find infrastructure/kubernetes -name "*.yaml" -exec sed -i "s/:latest/:${{ github.sha }}/g" {} \;
          
          # Apply all manifests
          kubectl apply -f infrastructure/kubernetes/manifests/ --recursive
          
          echo "âœ… Kubernetes manifests deployed"

      - name: Wait for deployment rollout
        run: |
          echo "â³ Waiting for deployment rollout..."
          
          # Wait for all deployments to be ready
          kubectl rollout status deployment/gong-webhook-service -n ${{ env.KUBERNETES_NAMESPACE }} --timeout=300s
          kubectl rollout status deployment/sophia-backend -n ${{ env.KUBERNETES_NAMESPACE }} --timeout=300s
          kubectl rollout status deployment/mcp-gateway -n ${{ env.KUBERNETES_NAMESPACE }} --timeout=300s
          
          echo "âœ… All deployments rolled out successfully"

      - name: Run health checks
        run: |
          echo "ðŸ¥ Running health checks..."
          
          # Check pod status
          kubectl get pods -n ${{ env.KUBERNETES_NAMESPACE }}
          
          # Check service endpoints
          kubectl get services -n ${{ env.KUBERNETES_NAMESPACE }}
          
          # Test webhook endpoint
          WEBHOOK_URL=$(kubectl get service gong-webhook-service -n ${{ env.KUBERNETES_NAMESPACE }} -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          if [ -n "$WEBHOOK_URL" ]; then
            curl -f http://$WEBHOOK_URL/health || echo "âš ï¸ Webhook health check failed"
          fi
          
          echo "âœ… Health checks completed"

  # Job 6: Run post-deployment tests
  post-deployment-tests:
    runs-on: ubuntu-latest
    needs: [detect-environment, deploy-kubernetes]
    if: needs.detect-environment.outputs.should_deploy == 'true' && needs.detect-environment.outputs.environment != 'prod'
    environment: ${{ needs.detect-environment.outputs.environment }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          pip install -r requirements.txt
          pip install -r requirements-dev.txt

      - name: Run smoke tests
        env:
          ENVIRONMENT: ${{ needs.detect-environment.outputs.environment }}
        run: |
          echo "ðŸ”¥ Running smoke tests..."
          python -m pytest tests/smoke/ -v --tb=short
          echo "âœ… Smoke tests passed"

      - name: Run end-to-end tests
        env:
          ENVIRONMENT: ${{ needs.detect-environment.outputs.environment }}
        run: |
          echo "ðŸ”„ Running end-to-end tests..."
          python -m pytest tests/e2e/ -v --tb=short
          echo "âœ… End-to-end tests passed"

  # Job 7: Update deployment status and notifications
  finalize-deployment:
    runs-on: ubuntu-latest
    needs: [detect-environment, deploy-kubernetes, post-deployment-tests]
    if: always() && needs.detect-environment.outputs.should_deploy == 'true'
    environment: ${{ needs.detect-environment.outputs.environment }}
    steps:
      - name: Determine deployment status
        id: status
        run: |
          if [[ "${{ needs.deploy-kubernetes.result }}" == "success" ]]; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "message=âœ… Sophia AI Platform deployed successfully to ${{ needs.detect-environment.outputs.environment }}" >> $GITHUB_OUTPUT
          else
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "message=âŒ Sophia AI Platform deployment failed for ${{ needs.detect-environment.outputs.environment }}" >> $GITHUB_OUTPUT
          fi

      - name: Update deployment status
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: context.payload.deployment?.id || 0,
              state: '${{ steps.status.outputs.status }}',
              environment: '${{ needs.detect-environment.outputs.environment }}',
              description: '${{ steps.status.outputs.message }}'
            });

      - name: Notify Slack on success
        if: steps.status.outputs.status == 'success'
        uses: 8398a7/action-slack@v3
        with:
          status: success
          channel: '#deployments'
          text: |
            ðŸš€ *Sophia AI Platform Deployment Success*
            
            â€¢ **Environment**: ${{ needs.detect-environment.outputs.environment }}
            â€¢ **Commit**: ${{ github.sha }}
            â€¢ **Author**: ${{ github.actor }}
            â€¢ **Duration**: ${{ job.duration }}
            
            All services are healthy and running! ðŸŽ‰
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Notify Slack on failure
        if: steps.status.outputs.status == 'failure'
        uses: 8398a7/action-slack@v3
        with:
          status: failure
          channel: '#deployments'
          text: |
            ðŸš¨ *Sophia AI Platform Deployment Failed*
            
            â€¢ **Environment**: ${{ needs.detect-environment.outputs.environment }}
            â€¢ **Commit**: ${{ github.sha }}
            â€¢ **Author**: ${{ github.actor }}
            â€¢ **Error**: Check GitHub Actions logs
            
            Please investigate immediately! ðŸ”¥
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Generate deployment report
        run: |
          echo "ðŸ“Š Deployment Report" > deployment-report.md
          echo "===================" >> deployment-report.md
          echo "" >> deployment-report.md
          echo "**Environment**: ${{ needs.detect-environment.outputs.environment }}" >> deployment-report.md
          echo "**Status**: ${{ steps.status.outputs.status }}" >> deployment-report.md
          echo "**Commit**: ${{ github.sha }}" >> deployment-report.md
          echo "**Author**: ${{ github.actor }}" >> deployment-report.md
          echo "**Timestamp**: $(date -u)" >> deployment-report.md
          echo "" >> deployment-report.md
          echo "**Components Deployed**:" >> deployment-report.md
          echo "- Gong Webhook Service" >> deployment-report.md
          echo "- Sophia Backend" >> deployment-report.md
          echo "- MCP Gateway" >> deployment-report.md
          echo "- Kubernetes Infrastructure" >> deployment-report.md
          echo "" >> deployment-report.md
          
          cat deployment-report.md

      - name: Archive deployment artifacts
        uses: actions/upload-artifact@v4
        with:
          name: deployment-report-${{ needs.detect-environment.outputs.environment }}-${{ github.sha }}
          path: |
            deployment-report.md
            infrastructure/stack-outputs.json
          retention-days: 30 