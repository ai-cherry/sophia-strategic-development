"""
Snowflake Client for Gong Webhook Data Storage.

Handles all Snowflake operations for storing raw and enhanced webhook data.
"""

from __future__ import annotations

import hashlib
import json
from typing import Any

import structlog
# REMOVED: Snowflake dependency - use UnifiedMemoryServiceV3 import DictCursor
# REMOVED: Snowflake dependency - use UnifiedMemoryServiceV3.pool import SnowflakePool

logger = structlog.get_logger()


class SnowflakeWebhookClient:
    """Client for Snowflake webhook data operations."""

    def __init__(
        self,
        account: str,
        user: str,
        password: str,
        warehouse: str = "SOPHIA_AI_WH",
        database: str = "SOPHIA_AI",
        schema: str = "GONG_WEBHOOKS",
        pool_size: int = 5,
    ):
        self.account = account
        self.user = user
        self.password = password
        self.warehouse = warehouse
        self.database = database
        self.schema = schema
        self.logger = logger.bind(component="snowflake_webhook_client")

        # Create connection pool
        self.pool = SnowflakePool(
            name="gong_webhook_pool",
            size=pool_size,
            account=account,
            user=user,
            password=password,
            warehouse=warehouse,
            database=database,
            schema=schema,
        )

        # Initialize tables on startup
        self._initialize_tables()

    def _initialize_tables(self):
        """Create tables if they don't exist."""
        with self.pool.get_connection() as conn:
            cursor = conn.cursor()

            # Raw webhook table
            cursor.execute(
                """
                CREATE TABLE IF NOT EXISTS gong_webhooks_raw (
                    webhook_id VARCHAR(255) PRIMARY KEY,
                    received_at TIMESTAMP_NTZ DEFAULT CURRENT_TIMESTAMP(),
                    processed_at TIMESTAMP_NTZ,
                    event_type VARCHAR(50),
                    object_id VARCHAR(255),
                    object_type VARCHAR(50),
                    raw_data VARIANT,
                    processing_status VARCHAR(50) DEFAULT 'pending',
                    error_message VARCHAR,
                    retry_count NUMBER DEFAULT 0,
                    created_at TIMESTAMP_NTZ DEFAULT CURRENT_TIMESTAMP()
                )
            """
            )

            # Enhanced call data table
            cursor.execute(
                """
                CREATE TABLE IF NOT EXISTS gong_calls_enhanced (
                    call_id VARCHAR(255) PRIMARY KEY,
                    webhook_id VARCHAR(255),
                    call_start_time TIMESTAMP_NTZ,
                    duration_seconds NUMBER,
                    title VARCHAR,
                    direction VARCHAR(50),
                    is_video BOOLEAN,
                    language VARCHAR(10),
                    purpose VARCHAR,
                    participants VARIANT,
                    transcript_data VARIANT,
                    analytics_data VARIANT,
                    topics VARIANT,
                    action_items VARIANT,
                    summary VARIANT,
                    enhanced_at TIMESTAMP_NTZ,
                    created_at TIMESTAMP_NTZ DEFAULT CURRENT_TIMESTAMP(),
                    updated_at TIMESTAMP_NTZ DEFAULT CURRENT_TIMESTAMP()
                )
            """
            )

            # Email data table
            cursor.execute(
                """
                CREATE TABLE IF NOT EXISTS gong_emails_enhanced (
                    email_id VARCHAR(255) PRIMARY KEY,
                    webhook_id VARCHAR(255),
                    subject VARCHAR,
                    sender VARCHAR,
                    recipients VARIANT,
                    sent_time TIMESTAMP_NTZ,
                    content VARIANT,
                    enhanced_at TIMESTAMP_NTZ,
                    created_at TIMESTAMP_NTZ DEFAULT CURRENT_TIMESTAMP()
                )
            """
            )

            # Meeting data table
            cursor.execute(
                """
                CREATE TABLE IF NOT EXISTS gong_meetings_enhanced (
                    meeting_id VARCHAR(255) PRIMARY KEY,
                    webhook_id VARCHAR(255),
                    title VARCHAR,
                    start_time TIMESTAMP_NTZ,
                    end_time TIMESTAMP_NTZ,
                    attendees VARIANT,
                    meeting_url VARCHAR,
                    enhanced_at TIMESTAMP_NTZ,
                    created_at TIMESTAMP_NTZ DEFAULT CURRENT_TIMESTAMP()
                )
            """
            )

            # Processing history table
            cursor.execute(
                """
                CREATE TABLE IF NOT EXISTS webhook_processing_history (
                    id NUMBER AUTOINCREMENT PRIMARY KEY,
                    webhook_id VARCHAR(255),
                    event_type VARCHAR(50),
                    stage VARCHAR(100),
                    status VARCHAR(50),
                    duration_ms NUMBER,
                    error_message VARCHAR,
                    metadata VARIANT,
                    created_at TIMESTAMP_NTZ DEFAULT CURRENT_TIMESTAMP()
                )
            """
            )

            conn.commit()
            self.logger.info("Snowflake tables initialized successfully")

    async def store_raw_webhook(self, webhook_data: dict[str, Any]) -> str:
        """Store raw webhook data for immediate response."""
        webhook_id = webhook_data.get(
            "webhook_id", self._generate_webhook_id(webhook_data)
        )

        with self.pool.get_connection() as conn:
            cursor = conn.cursor(DictCursor)

            try:
                cursor.execute(
                    """
                    INSERT INTO gong_webhooks_raw (
                        webhook_id, event_type, object_id, object_type, raw_data
                    ) VALUES (%s, %s, %s, %s, %s)
                """,
                    (
                        webhook_id,
                        webhook_data.get("event_type", "unknown"),
                        webhook_data.get("object_id", ""),
                        webhook_data.get("object_type", ""),
                        json.dumps(webhook_data),
                    ),
                )

                conn.commit()
                self.logger.info("Raw webhook stored", webhook_id=webhook_id)
                return webhook_id

            except Exception as e:
                conn.rollback()
                self.logger.exception(
                    "Failed to store raw webhook", webhook_id=webhook_id, error=str(e)
                )
                raise

    async def update_webhook_status(
        self, webhook_id: str, status: str, error_message: str | None = None
    ):
        """Update webhook processing status."""
        with self.pool.get_connection() as conn:
            cursor = conn.cursor()

            try:
                if error_message:
                    cursor.execute(
                        """
                        UPDATE gong_webhooks_raw
                        SET processing_status = %s,
                            error_message = %s,
                            processed_at = CURRENT_TIMESTAMP(),
                            retry_count = retry_count + 1
                        WHERE webhook_id = %s
                    """,
                        (status, error_message, webhook_id),
                    )
                else:
                    cursor.execute(
                        """
                        UPDATE gong_webhooks_raw
                        SET processing_status = %s,
                            processed_at = CURRENT_TIMESTAMP()
                        WHERE webhook_id = %s
                    """,
                        (status, webhook_id),
                    )

                conn.commit()

            except Exception as e:
                conn.rollback()
                self.logger.exception(
                    "Failed to update webhook status",
                    webhook_id=webhook_id,
                    error=str(e),
                )
                raise

    async def store_enhanced_call_data(self, enhanced_data: dict[str, Any]):
        """Store enhanced call data."""
        call_data = enhanced_data.get("call_data", {})

        with self.pool.get_connection() as conn:
            cursor = conn.cursor()

            try:
                cursor.execute(
                    """
                    MERGE INTO gong_calls_enhanced AS target
                    USING (SELECT %s AS call_id) AS source
                    ON target.call_id = source.call_id
                    WHEN MATCHED THEN UPDATE SET
                        webhook_id = %s,
                        call_start_time = %s,
                        duration_seconds = %s,
                        title = %s,
                        direction = %s,
                        is_video = %s,
                        language = %s,
                        purpose = %s,
                        participants = %s,
                        transcript_data = %s,
                        analytics_data = %s,
                        topics = %s,
                        action_items = %s,
                        summary = %s,
                        enhanced_at = %s,
                        updated_at = CURRENT_TIMESTAMP()
                    WHEN NOT MATCHED THEN INSERT (
                        call_id, webhook_id, call_start_time, duration_seconds,
                        title, direction, is_video, language, purpose,
                        participants, transcript_data, analytics_data,
                        topics, action_items, summary, enhanced_at
                    ) VALUES (
                        %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s
                    )
                """,
                    (
                        # For MERGE condition
                        enhanced_data["call_id"],
                        # For UPDATE
                        enhanced_data.get("webhook_id"),
                        call_data.get("started"),
                        call_data.get("duration"),
                        call_data.get("title"),
                        call_data.get("direction"),
                        call_data.get("is_video"),
                        call_data.get("language"),
                        call_data.get("purpose"),
                        json.dumps(call_data.get("participants", [])),
                        json.dumps(enhanced_data.get("transcript")),
                        json.dumps(enhanced_data.get("analytics")),
                        json.dumps(call_data.get("topics", [])),
                        json.dumps(call_data.get("action_items", [])),
                        json.dumps(call_data.get("summary")),
                        enhanced_data.get("enhanced_at"),
                        # For INSERT
                        enhanced_data["call_id"],
                        enhanced_data.get("webhook_id"),
                        call_data.get("started"),
                        call_data.get("duration"),
                        call_data.get("title"),
                        call_data.get("direction"),
                        call_data.get("is_video"),
                        call_data.get("language"),
                        call_data.get("purpose"),
                        json.dumps(call_data.get("participants", [])),
                        json.dumps(enhanced_data.get("transcript")),
                        json.dumps(enhanced_data.get("analytics")),
                        json.dumps(call_data.get("topics", [])),
                        json.dumps(call_data.get("action_items", [])),
                        json.dumps(call_data.get("summary")),
                        enhanced_data.get("enhanced_at"),
                    ),
                )

                conn.commit()
                self.logger.info(
                    "Enhanced call data stored", call_id=enhanced_data["call_id"]
                )

            except Exception as e:
                conn.rollback()
                self.logger.exception(
                    "Failed to store enhanced call data",
                    call_id=enhanced_data.get("call_id"),
                    error=str(e),
                )
                raise

    async def log_processing_stage(
        self,
        webhook_id: str,
        event_type: str,
        stage: str,
        status: str,
        duration_ms: int | None = None,
        error_message: str | None = None,
        metadata: dict[str, Any] | None = None,
    ):
        """Log webhook processing stages for monitoring."""
        with self.pool.get_connection() as conn:
            cursor = conn.cursor()

            try:
                cursor.execute(
                    """
                    INSERT INTO webhook_processing_history (
                        webhook_id, event_type, stage, status,
                        duration_ms, error_message, metadata
                    ) VALUES (%s, %s, %s, %s, %s, %s, %s)
                """,
                    (
                        webhook_id,
                        event_type,
                        stage,
                        status,
                        duration_ms,
                        error_message,
                        json.dumps(metadata) if metadata else None,
                    ),
                )

                conn.commit()

            except Exception as e:
                self.logger.exception(
                    "Failed to log processing stage",
                    webhook_id=webhook_id,
                    stage=stage,
                    error=str(e),
                )

    async def get_pending_webhooks(self, limit: int = 100) -> list[dict[str, Any]]:
        """Get pending webhooks for reprocessing."""
        with self.pool.get_connection() as conn:
            cursor = conn.cursor(DictCursor)

            cursor.execute(
                """
                SELECT webhook_id, event_type, object_id, raw_data, retry_count
                FROM gong_webhooks_raw
                WHERE processing_status IN ('pending', 'failed')
                  AND retry_count < 5
                  AND received_at > DATEADD(day, -7, CURRENT_TIMESTAMP())
                ORDER BY received_at
                LIMIT %s
            """,
                (limit,),
            )

            return cursor.fetchall()

    async def batch_insert(self, table: str, data_list: list[dict[str, Any]]):
        """Efficient batch insertion."""
        if not data_list:
            return

        with self.pool.get_connection() as conn:
            cursor = conn.cursor()

            try:
                # Prepare batch insert based on first record
                columns = list(data_list[0].keys())
                placeholders = ", ".join(["%s"] * len(columns))

                query = f"""
                    INSERT INTO {table} ({", ".join(columns)})
                    VALUES ({placeholders})
                """

                # Execute batch insert
                cursor.executemany(
                    query,
                    [tuple(record.get(col) for col in columns) for record in data_list],
                )

                conn.commit()
                self.logger.info(
                    f"Batch inserted {len(data_list)} records", table=table
                )

            except Exception as e:
                conn.rollback()
                self.logger.exception("Batch insert failed", table=table, error=str(e))
                raise

    def _generate_webhook_id(self, data: dict[str, Any]) -> str:
        """Generate deterministic webhook ID."""
        content = json.dumps(data, sort_keys=True)
        return hashlib.sha256(content.encode()).hexdigest()[:16]

    def close(self):
        """Close the connection pool."""
        self.pool.close()
