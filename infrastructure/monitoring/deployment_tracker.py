from backend.services.unified_memory_service import UnifiedMemoryService
import shlex
from datetime import UTC, datetime

"""
Sophia AI - Enhanced Deployment Tracking & Monitoring System
Provides real-time deployment monitoring, tracking, and automated rollback capabilities
"""

"""
File Decomposition Plan (auto-generated by Phase 3)
Current size: 776 lines

Recommended decomposition:
- deployment_tracker_core.py - Core functionality
- deployment_tracker_utils.py - Utility functions
- deployment_tracker_models.py - Data models
- deployment_tracker_handlers.py - Request handlers

"""

import json
import logging
import subprocess
from dataclasses import dataclass
from enum import Enum
from typing import Any

from backend.services.unified_memory_service import UnifiedMemoryService

logger = logging.getLogger(__name__)


class DeploymentStatus(Enum):
    """Deployment status enumeration."""

    INITIATED = "INITIATED"
    IN_PROGRESS = "IN_PROGRESS"
    COMPLETED = "COMPLETED"
    FAILED = "FAILED"
    ROLLED_BACK = "ROLLED_BACK"
    ROLLBACK_IN_PROGRESS = "ROLLBACK_IN_PROGRESS"


class ComponentType(Enum):
    """Component type enumeration."""

    INFRASTRUCTURE = "infrastructure"
    MCP_SERVERS = "mcp_servers"
    FRONTEND = "frontend"
    DATA_PIPELINE = "data_pipeline"
    INTEGRATION = "integration"
    MONITORING = "monitoring"


class Environment(Enum):
    """Deployment environment enumeration."""

    PRODUCTION = "production"
    STAGING = "staging"
    DEVELOPMENT = "development"


@dataclass
class DeploymentEvent:
    """Deployment event data structure."""

    deployment_id: str
    component: ComponentType
    environment: Environment
    version: str
    status: DeploymentStatus
    timestamp: datetime
    duration_seconds: int | None = None
    github_sha: str | None = None
    github_ref: str | None = None
    github_actor: str | None = None
    error_message: str | None = None
    rollback_target: str | None = None
    metadata: dict[str, Any] | None = None


@dataclass
class DeploymentHealth:
    """Deployment health status."""

    component: ComponentType
    environment: Environment
    status: str
    last_deployment: datetime | None
    success_rate: float
    average_duration: float
    issues: list[str]


@dataclass
class RollbackPlan:
    """Rollback plan data structure."""

    deployment_id: str
    component: ComponentType
    environment: Environment
    current_version: str
    target_version: str
    rollback_steps: list[str]
    estimated_duration: int
    risk_level: str


class EnhancedDeploymentTracker:
    """Enhanced deployment tracking with monitoring and rollback capabilities."""

    def __init__(self):
        self.memory_service_v3 = UnifiedMemoryService()
        self.deployment_history: list[DeploymentEvent] = []
        self.active_deployments: dict[str, DeploymentEvent] = {}

    async def initialize_tracking_schema(self) -> bool:
        """Initialize deployment tracking schema in Qdrant."""
        try:
            schema_sql = """
            -- Deployment Tracking Schema
            CREATE SCHEMA IF NOT EXISTS SOPHIA_AI.DEPLOYMENT_TRACKING;
            USE SCHEMA SOPHIA_AI.DEPLOYMENT_TRACKING;

            -- Deployment Events Table
            CREATE TABLE IF NOT EXISTS DEPLOYMENT_EVENTS (
                deployment_id VARCHAR(50) PRIMARY KEY,
                component VARCHAR(50) NOT NULL,
                environment VARCHAR(20) NOT NULL,
                version VARCHAR(50) NOT NULL,
                status VARCHAR(30) NOT NULL,
                timestamp TIMESTAMP_NTZ NOT NULL,
                duration_seconds INTEGER,
                github_sha VARCHAR(40),
                github_ref VARCHAR(100),
                github_actor VARCHAR(50),
                error_message TEXT,
                rollback_target VARCHAR(50),
                metadata VARIANT,
                created_at TIMESTAMP_NTZ DEFAULT CURRENT_TIMESTAMP(),
                updated_at TIMESTAMP_NTZ DEFAULT CURRENT_TIMESTAMP()
            );

            -- Deployment Health View
            CREATE OR REPLACE VIEW DEPLOYMENT_HEALTH AS
            SELECT
                component,
                environment,
                COUNT(*) as total_deployments,
                SUM(CASE WHEN status = 'COMPLETED' THEN 1 ELSE 0 END) as successful_deployments,
                ROUND(successful_deployments / total_deployments * 100, 2) as success_rate,
                AVG(duration_seconds) as avg_duration_seconds,
                MAX(timestamp) as last_deployment,
                MIN(timestamp) as first_deployment
            FROM DEPLOYMENT_EVENTS
            WHERE timestamp >= DATEADD(DAY, -30, CURRENT_TIMESTAMP())
            GROUP BY component, environment;

            -- Component Status Table
            CREATE TABLE IF NOT EXISTS COMPONENT_STATUS (
                component VARCHAR(50),
                environment VARCHAR(20),
                current_version VARCHAR(50),
                deployment_id VARCHAR(50),
                status VARCHAR(30),
                health_score FLOAT,
                last_check TIMESTAMP_NTZ,
                issues VARIANT,
                PRIMARY KEY (component, environment)
            );

            -- Rollback History Table
            CREATE TABLE IF NOT EXISTS ROLLBACK_HISTORY (
                rollback_id VARCHAR(50) PRIMARY KEY,
                original_deployment_id VARCHAR(50),
                component VARCHAR(50),
                environment VARCHAR(20),
                from_version VARCHAR(50),
                to_version VARCHAR(50),
                initiated_by VARCHAR(50),
                initiated_at TIMESTAMP_NTZ,
                completed_at TIMESTAMP_NTZ,
                status VARCHAR(30),
                reason TEXT
            );
            """

            await self.memory_service_v3.execute_query(schema_sql)
            logger.info("✅ Deployment tracking schema initialized successfully")
            return True

        except Exception as e:
            logger.exception(f"❌ Failed to initialize deployment tracking schema: {e}")
            return False

    def generate_deployment_id(
        self, component: ComponentType, environment: Environment
    ) -> str:
        """Generate unique deployment ID."""
        timestamp = datetime.now(UTC).strftime("%Y%m%d-%H%M%S")
        return f"{component.value}-{environment.value}-{timestamp}"

    async def start_deployment(
        self,
        component: ComponentType,
        environment: Environment,
        version: str,
        metadata: dict[str, Any] | None = None,
    ) -> str:
        """Start tracking a new deployment."""

        deployment_id = self.generate_deployment_id(component, environment)

        # Gather GitHub context
        github_context = self._get_github_context()

        deployment_event = DeploymentEvent(
            deployment_id=deployment_id,
            component=component,
            environment=environment,
            version=version,
            status=DeploymentStatus.INITIATED,
            timestamp=datetime.now(UTC),
            github_sha=github_context.get("sha"),
            github_ref=github_context.get("ref"),
            github_actor=github_context.get("actor"),
            metadata=metadata or {},
        )

        # Store in active deployments
        self.active_deployments[deployment_id] = deployment_event

        # Store in Qdrant
        await self._store_deployment_event(deployment_event)

        # Send notification
        await self._send_deployment_notification(deployment_event, "started")

        logger.info(f"🚀 Started deployment tracking: {deployment_id}")
        return deployment_id

    async def update_deployment_status(
        self,
        deployment_id: str,
        status: DeploymentStatus,
        error_message: str | None = None,
    ) -> bool:
        """Update deployment status."""

        if deployment_id not in self.active_deployments:
            logger.error(
                f"❌ Deployment {deployment_id} not found in active deployments"
            )
            return False

        deployment = self.active_deployments[deployment_id]
        deployment.status = status
        deployment.error_message = error_message

        if status in [DeploymentStatus.COMPLETED, DeploymentStatus.FAILED]:
            # Calculate duration
            deployment.duration_seconds = int(
                (datetime.now(UTC) - deployment.timestamp).total_seconds()
            )

            # Move to history
            self.deployment_history.append(deployment)
            del self.active_deployments[deployment_id]

        # Update in Qdrant
        await self._store_deployment_event(deployment)

        # Send notification
        await self._send_deployment_notification(deployment, status.value.lower())

        # Check if rollback is needed
        if status == DeploymentStatus.FAILED:
            await self._check_auto_rollback(deployment)

        logger.info(f"📊 Updated deployment {deployment_id}: {status.value}")
        return True

    async def complete_deployment(
        self, deployment_id: str, success: bool, error_message: str | None = None
    ) -> bool:
        """Complete deployment tracking."""

        status = DeploymentStatus.COMPLETED if success else DeploymentStatus.FAILED
        return await self.update_deployment_status(deployment_id, status, error_message)

    async def get_deployment_health(
        self,
        component: ComponentType | None = None,
        environment: Environment | None = None,
    ) -> list[DeploymentHealth]:
        """Get deployment health status."""

        query = """
        SELECT
            component,
            environment,
            CASE
                WHEN success_rate >= 95 THEN 'HEALTHY'
                WHEN success_rate >= 80 THEN 'WARNING'
                ELSE 'CRITICAL'
            END as status,
            last_deployment,
            success_rate,
            avg_duration_seconds
        FROM DEPLOYMENT_HEALTH
        """

        conditions = []
        if component:
            conditions.append(f"component = '{component.value}'")
        if environment:
            conditions.append(f"environment = '{environment.value}'")

        if conditions:
            query += " WHERE " + " AND ".join(conditions)

        query += " ORDER BY component, environment"

        try:
            results = await self.memory_service_v3.execute_query(query)

            health_status = []
            for row in results:
                # Check for specific issues
                issues = await self._detect_deployment_issues(
                    ComponentType(row["COMPONENT"]), Environment(row["ENVIRONMENT"])
                )

                health = DeploymentHealth(
                    component=ComponentType(row["COMPONENT"]),
                    environment=Environment(row["ENVIRONMENT"]),
                    status=row["STATUS"],
                    last_deployment=row["LAST_DEPLOYMENT"],
                    success_rate=float(row["SUCCESS_RATE"]),
                    average_duration=float(row["AVG_DURATION_SECONDS"]),
                    issues=issues,
                )
                health_status.append(health)

            return health_status

        except Exception as e:
            logger.exception(f"❌ Failed to get deployment health: {e}")
            return []

    async def generate_rollback_plan(
        self,
        component: ComponentType,
        environment: Environment,
        target_version: str | None = None,
    ) -> RollbackPlan | None:
        """Generate rollback plan for a component."""

        try:
            # Get current version
            current_version = await self._get_current_version(component, environment)

            # Get target version (last successful deployment if not specified)
            if not target_version:
                target_version = await self._get_last_successful_version(
                    component, environment
                )

            if not target_version:
                logger.error("❌ No target version found for rollback")
                return None

            # Generate deployment ID for rollback
            deployment_id = self.generate_deployment_id(component, environment)

            # Define rollback steps based on component type
            rollback_steps = self._get_rollback_steps(
                component, environment, target_version
            )

            # Estimate duration based on historical data
            estimated_duration = await self._estimate_rollback_duration(
                component, environment
            )

            # Assess risk level
            risk_level = self._assess_rollback_risk(component, environment)

            rollback_plan = RollbackPlan(
                deployment_id=deployment_id,
                component=component,
                environment=environment,
                current_version=current_version,
                target_version=target_version,
                rollback_steps=rollback_steps,
                estimated_duration=estimated_duration,
                risk_level=risk_level,
            )

            logger.info(f"📋 Generated rollback plan: {deployment_id}")
            return rollback_plan

        except Exception as e:
            logger.exception(f"❌ Failed to generate rollback plan: {e}")
            return None

    async def execute_rollback(self, rollback_plan: RollbackPlan) -> bool:
        """Execute rollback plan."""

        try:
            # Start rollback tracking
            rollback_id = await self.start_deployment(
                rollback_plan.component,
                rollback_plan.environment,
                rollback_plan.target_version,
                metadata={
                    "rollback": True,
                    "original_version": rollback_plan.current_version,
                    "rollback_reason": "automated_rollback",
                },
            )

            await self.update_deployment_status(
                rollback_id, DeploymentStatus.ROLLBACK_IN_PROGRESS
            )

            # Execute rollback steps
            for i, step in enumerate(rollback_plan.rollback_steps):
                logger.info(
                    f"🔄 Executing rollback step {i + 1}/{len(rollback_plan.rollback_steps)}: {step}"
                )

                success = await self._execute_rollback_step(step, rollback_plan)

                if not success:
                    await self.update_deployment_status(
                        rollback_id,
                        DeploymentStatus.FAILED,
                        f"Rollback failed at step: {step}",
                    )
                    return False

            # Complete rollback
            await self.update_deployment_status(
                rollback_id, DeploymentStatus.ROLLED_BACK
            )

            # Update component status
            await self._update_component_status(
                rollback_plan.component,
                rollback_plan.environment,
                rollback_plan.target_version,
                rollback_id,
            )

            logger.info(f"✅ Rollback completed successfully: {rollback_id}")
            return True

        except Exception as e:
            logger.exception(f"❌ Rollback execution failed: {e}")
            return False

    def _get_github_context(self) -> dict[str, str]:
        """Get GitHub context from environment variables."""
        return {
            "sha": get_config_value("github_sha", ""),
            "ref": get_config_value("github_ref", ""),
            "actor": get_config_value("github_actor", ""),
            "workflow": get_config_value("github_workflow", ""),
            "job": get_config_value("github_job", ""),
        }

    async def _store_deployment_event(self, event: DeploymentEvent) -> bool:
        """Store deployment event in Qdrant."""

        try:
            query = """
            MERGE INTO SOPHIA_AI.DEPLOYMENT_TRACKING.DEPLOYMENT_EVENTS AS target
            USING (
                SELECT
                    %s as deployment_id,
                    %s as component,
                    %s as environment,
                    %s as version,
                    %s as status,
                    %s as timestamp,
                    %s as duration_seconds,
                    %s as github_sha,
                    %s as github_ref,
                    %s as github_actor,
                    %s as error_message,
                    %s as rollback_target,
                    PARSE_JSON(%s) as metadata
            ) AS source
            ON target.deployment_id = source.deployment_id
            WHEN MATCHED THEN
                UPDATE SET
                    status = source.status,
                    duration_seconds = source.duration_seconds,
                    error_message = source.error_message,
                    rollback_target = source.rollback_target,
                    updated_at = CURRENT_TIMESTAMP()
            WHEN NOT MATCHED THEN
                INSERT (
                    deployment_id, component, environment, version, status,
                    timestamp, duration_seconds, github_sha, github_ref,
                    github_actor, error_message, rollback_target, metadata
                ) VALUES (
                    source.deployment_id, source.component, source.environment,
                    source.version, source.status, source.timestamp,
                    source.duration_seconds, source.github_sha, source.github_ref,
                    source.github_actor, source.error_message, source.rollback_target,
                    source.metadata
                )
            """

            params = [
                event.deployment_id,
                event.component.value,
                event.environment.value,
                event.version,
                event.status.value,
                event.timestamp.isoformat(),
                event.duration_seconds,
                event.github_sha,
                event.github_ref,
                event.github_actor,
                event.error_message,
                event.rollback_target,
                json.dumps(event.metadata or {}),
            ]

            await self.memory_service_v3.execute_query(query, params)
            return True

        except Exception as e:
            logger.exception(f"❌ Failed to store deployment event: {e}")
            return False

    async def _send_deployment_notification(
        self, event: DeploymentEvent, action: str
    ) -> bool:
        """Send deployment notification."""

        try:
            # Prepare notification message
            emoji_map = {
                "started": "🚀",
                "completed": "✅",
                "failed": "❌",
                "rolled_back": "🔄",
            }

            emoji = emoji_map.get(action, "📊")

            message = f"""
{emoji} **Deployment {action.title()}**
• **Component**: {event.component.value}
• **Environment**: {event.environment.value}
• **Version**: {event.version}
• **ID**: {event.deployment_id}
"""

            if event.duration_seconds:
                message += f"• **Duration**: {event.duration_seconds}s\n"

            if event.error_message:
                message += f"• **Error**: {event.error_message}\n"

            if event.github_sha:
                message += f"• **Commit**: {event.github_sha[:8]}\n"

            # Send to configured notification channels
            # (Implementation would depend on configured notification system)
            logger.info(f"📢 Deployment notification: {message}")

            return True

        except Exception as e:
            logger.exception(f"❌ Failed to send deployment notification: {e}")
            return False

    async def _check_auto_rollback(self, event: DeploymentEvent) -> bool:
        """Check if automatic rollback should be triggered."""

        # Auto-rollback criteria
        if event.environment == Environment.PRODUCTION:
            # Check failure rate in last hour
            recent_failures = await self._get_recent_failure_count(
                event.component, event.environment, hours=1
            )

            if recent_failures >= 2:  # 2 failures in 1 hour triggers auto-rollback
                logger.warning(f"🚨 Auto-rollback triggered for {event.deployment_id}")

                rollback_plan = await self.generate_rollback_plan(
                    event.component, event.environment
                )

                if rollback_plan:
                    return await self.execute_rollback(rollback_plan)

        return False

    def _get_rollback_steps(
        self, component: ComponentType, environment: Environment, target_version: str
    ) -> list[str]:
        """Get rollback steps for component type."""

        rollback_steps = {
            ComponentType.INFRASTRUCTURE: [
                f"pulumi stack select sophia-infrastructure-{environment.value}",
                f"pulumi config set version {target_version}",
                "pulumi up --yes --skip-preview",
                "pulumi stack output --json > deployment-status.json",
            ],
            ComponentType.MCP_SERVERS: [
                "helm upgrade sophia-mcp ./infrastructure/kubernetes/helm/sophia-mcp",
                f"--set global.imageTag={target_version}",
                f"--set global.environment={environment.value}",
                "--wait --timeout=300s",
                "kubectl rollout status deployment/sophia-mcp-ai-memory -n sophia-mcp",
            ],
            ComponentType.FRONTEND: [
                f"vercel env pull .env.{environment.value}",
                (
                    "vercel deploy --prod"
                    if environment == Environment.PRODUCTION
                    else "vercel deploy"
                ),
                "vercel alias set",
            ],
        }

        return rollback_steps.get(
            component, [f"echo 'No rollback steps defined for {component.value}'"]
        )

    async def _execute_rollback_step(
        self, step: str, rollback_plan: RollbackPlan
    ) -> bool:
        """Execute individual rollback step."""

        try:
            # Parse step and execute
            if step.startswith("pulumi"):
                result = subprocess.run(
                    step.split(),
                    check=False,
                    capture_output=True,
                    text=True,
                    timeout=300,
                )
            elif step.startswith("helm"):
                result = subprocess.run(
                    step.split(),
                    check=False,
                    capture_output=True,
                    text=True,
                    timeout=600,
                )
            elif step.startswith("kubectl"):
                result = subprocess.run(
                    step.split(),
                    check=False,
                    capture_output=True,
                    text=True,
                    timeout=300,
                )
            elif step.startswith("vercel"):
                result = subprocess.run(
                    step.split(),
                    check=False,
                    capture_output=True,
                    text=True,
                    timeout=180,
                )
            else:
                # Generic shell command
                result = subprocess.run(
                    shlex.split(step),
                    check=False,
                    capture_output=True,
                    text=True,
                    timeout=120,
                )  # SECURITY FIX: Removed shell=True

            if result.returncode == 0:
                logger.info(f"✅ Rollback step completed: {step}")
                return True
            else:
                logger.error(f"❌ Rollback step failed: {step} - {result.stderr}")
                return False

        except subprocess.TimeoutExpired:
            logger.exception(f"⏱️ Rollback step timed out: {step}")
            return False
        except Exception as e:
            logger.exception(f"❌ Rollback step error: {step} - {e}")
            return False

    async def _get_current_version(
        self, component: ComponentType, environment: Environment
    ) -> str | None:
        """Get current deployed version."""

        try:
            query = """
            SELECT version
            FROM SOPHIA_AI.DEPLOYMENT_TRACKING.COMPONENT_STATUS
            WHERE component = %s AND environment = %s
            """

            results = await self.memory_service_v3.execute_query(
                query, [component.value, environment.value]
            )

            if results:
                return results[0]["VERSION"]

            return None

        except Exception as e:
            logger.exception(f"❌ Failed to get current version: {e}")
            return None

    async def _get_last_successful_version(
        self, component: ComponentType, environment: Environment
    ) -> str | None:
        """Get last successful deployment version."""

        try:
            query = """
            SELECT version
            FROM SOPHIA_AI.DEPLOYMENT_TRACKING.DEPLOYMENT_EVENTS
            WHERE component = %s
              AND environment = %s
              AND status = 'COMPLETED'
            ORDER BY timestamp DESC
            LIMIT 1
            """

            results = await self.memory_service_v3.execute_query(
                query, [component.value, environment.value]
            )

            if results:
                return results[0]["VERSION"]

            return None

        except Exception as e:
            logger.exception(f"❌ Failed to get last successful version: {e}")
            return None

    async def _detect_deployment_issues(
        self, component: ComponentType, environment: Environment
    ) -> list[str]:
        """Detect deployment issues for a component."""

        issues = []

        try:
            # Check recent failure rate
            query = """
            SELECT COUNT(*) as total_deployments,
                   SUM(CASE WHEN status = 'FAILED' THEN 1 ELSE 0 END) as failed_deployments
            FROM SOPHIA_AI.DEPLOYMENT_TRACKING.DEPLOYMENT_EVENTS
            WHERE component = %s
              AND environment = %s
              AND timestamp >= DATEADD(DAY, -7, CURRENT_TIMESTAMP())
            """

            results = await self.memory_service_v3.execute_query(
                query, [component.value, environment.value]
            )

            if results:
                total = results[0]["TOTAL_DEPLOYMENTS"]
                failed = results[0]["FAILED_DEPLOYMENTS"]

                if total > 0 and (failed / total) > 0.2:  # More than 20% failure rate
                    issues.append(
                        f"High failure rate: {failed}/{total} deployments failed in last 7 days"
                    )

            # Check deployment frequency
            if total == 0:
                issues.append("No deployments in last 7 days")

            # Add component-specific health checks
            if component == ComponentType.MCP_SERVERS:
                # Check MCP server health
                # (Implementation would check actual server endpoints)
                pass

        except Exception as e:
            logger.exception(f"❌ Failed to detect deployment issues: {e}")
            issues.append(f"Health check failed: {e!s}")

        return issues


# Global deployment tracker instance
deployment_tracker = EnhancedDeploymentTracker()


async def initialize_deployment_tracking():
    """Initialize deployment tracking system."""
    await deployment_tracker.initialize_tracking_schema()
    logger.info("🚀 Enhanced Deployment Tracking System initialized")
