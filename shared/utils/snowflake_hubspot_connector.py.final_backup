# SQL Injection fixes applied by phase1_ruff_remediation.py
"""
Snowflake HubSpot Connector

Utility module for accessing HubSpot data directly from Snowflake Secure Data Share.
This provides a hybrid approach where we maintain existing ingestion capabilities
while adding enterprise-grade Snowflake native access for analytics and AI processing.

Key Features:
- Direct access to HubSpot Secure Data Share within Snowflake
- Integration with Snowflake Cortex for AI processing
- Blended approach with existing ingestion for training/interaction
- Optimized for BI agents and contextual analysis
"""

from __future__ import annotations

import logging
from dataclasses import dataclass
from datetime import datetime, timedelta
from typing import Any

import pandas as pd
# REMOVED: Snowflake dependency - use UnifiedMemoryServiceV3

from core.config_manager import get_config_value as config

logger = logging.getLogger(__name__)


@dataclass
class HubSpotDataQuery:
    """Configuration for HubSpot data queries via Snowflake"""

    table_name: str
    filters: dict[str, Any]
    date_range: dict[str, datetime] | None = None
    limit: int | None = None
    columns: list[str] | None = None


class SnowflakeHubSpotConnector:
    """
    Connector for accessing HubSpot data via Snowflake Secure Data Share

    This class provides methods to query HubSpot data directly within Snowflake,
    leveraging native Snowflake capabilities while maintaining compatibility
    with existing ingestion patterns.
    """

    def __init__(self):
        self.connection = None
        self.hubspot_database = (
            "HUBSPOT_SECURE_SHARE"  # Placeholder - actual share name
        )
        self.hubspot_schema = "PUBLIC"
        self.initialized = False

        # Common HubSpot table mappings (to be updated with actual share structure)
        self.table_mappings = {
            "contacts": "CONTACTS",
            "companies": "COMPANIES",
            "deals": "DEALS",
            "deal_stages": "DEAL_STAGES",
            "activities": "ACTIVITIES",
            "emails": "EMAILS",
            "meetings": "MEETINGS",
            "calls": "CALLS",
            "notes": "NOTES",
            "tasks": "TASKS",
            "properties": "PROPERTIES",
        }

    async def __aenter__(self):
        """Async context manager entry - initialize connection"""
        await self.initialize()
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Async context manager exit - cleanup resources"""
        await self.close()

    async def initialize(self) -> None:
        """Initialize Snowflake connection for HubSpot data access"""
        if self.initialized:
            return

        try:
# REMOVED: Snowflake dependency
            self.connection = self.modern_stack_connection(
                user=config.get("snowflake_user"),
                password=config.get("snowflake_password"),
                account=config.get("snowflake_account"),
                warehouse=config.get("snowflake_warehouse", "SOPHIA_AI_WH"),
                database=self.hubspot_database,
                schema=self.hubspot_schema,
                role=config.get("snowflake_role", "ACCOUNTADMIN"),
            )

            self.initialized = True
            logger.info("âœ… Snowflake HubSpot connector initialized successfully")

        except Exception as e:
            logger.exception(f"Failed to initialize Snowflake HubSpot connector: {e}")
            raise

    async def query_hubspot_contacts(
        self,
        filters: dict[str, Any] | None = None,
        date_range: dict[str, datetime] | None = None,
        limit: int | None = 1000,
    ) -> pd.DataFrame:
        """
        Query HubSpot contacts from Snowflake Secure Data Share

        Args:
            filters: Dictionary of filter conditions
            date_range: Date range for filtering (created_date, modified_date)
            limit: Maximum number of records to return

        Returns:
            DataFrame with contact data ready for AI processing
        """
        if not self.initialized:
            await self.initialize()

        query = self._build_contact_query(filters, date_range, limit)

        try:
            cursor = self.connection.cursor()
            cursor.execute(query)

            # Convert to DataFrame for easy processing
            columns = [desc[0] for desc in cursor.description]
            data = cursor.fetchall()
            df = pd.DataFrame(data, columns=columns)

            logger.info(f"Retrieved {len(df)} contacts from HubSpot Secure Data Share")
            return df

        except Exception as e:
            logger.exception(f"Error querying HubSpot contacts: {e}")
            raise
        finally:
            if cursor:
                cursor.close()

    async def query_hubspot_deals(
        self,
        pipeline_filters: list[str] | None = None,
        stage_filters: list[str] | None = None,
        date_range: dict[str, datetime] | None = None,
        limit: int | None = 1000,
    ) -> pd.DataFrame:
        """
        Query HubSpot deals with pipeline and stage filtering

        Args:
            pipeline_filters: List of pipeline names/IDs to include
            stage_filters: List of deal stages to include
            date_range: Date range for filtering
            limit: Maximum number of records

        Returns:
            DataFrame with deal data optimized for revenue analysis
        """
        if not self.initialized:
            await self.initialize()

        query = self._build_deals_query(
            pipeline_filters, stage_filters, date_range, limit
        )

        try:
            cursor = self.connection.cursor()
            cursor.execute(query)

            columns = [desc[0] for desc in cursor.description]
            data = cursor.fetchall()
            df = pd.DataFrame(data, columns=columns)

            logger.info(f"Retrieved {len(df)} deals from HubSpot Secure Data Share")
            return df

        except Exception as e:
            logger.exception(f"Error querying HubSpot deals: {e}")
            raise
        finally:
            if cursor:
                cursor.close()

    async def query_hubspot_activities(
        self,
        activity_types: list[str] | None = None,
        contact_ids: list[str] | None = None,
        date_range: dict[str, datetime] | None = None,
        limit: int | None = 5000,
    ) -> pd.DataFrame:
        """
        Query HubSpot activities (emails, calls, meetings, notes)

        Args:
            activity_types: Types of activities to include
            contact_ids: Specific contact IDs to filter by
            date_range: Date range for activity filtering
            limit: Maximum number of activities

        Returns:
            DataFrame with activity data for interaction analysis
        """
        if not self.initialized:
            await self.initialize()

        query = self._build_activities_query(
            activity_types, contact_ids, date_range, limit
        )

        try:
            cursor = self.connection.cursor()
            cursor.execute(query)

            columns = [desc[0] for desc in cursor.description]
            data = cursor.fetchall()
            df = pd.DataFrame(data, columns=columns)

            logger.info(
                f"Retrieved {len(df)} activities from HubSpot Secure Data Share"
            )
            return df

        except Exception as e:
            logger.exception(f"Error querying HubSpot activities: {e}")
            raise
        finally:
            if cursor:
                cursor.close()

    def _build_contact_query(
        self,
        filters: dict[str, Any] | None,
        date_range: dict[str, datetime] | None,
        limit: int | None,
    ) -> str:
        """Build SQL query for HubSpot contacts"""

        base_query = """

        SELECT
            contact_id,
            email,
            firstname,
            lastname,
            company,
            jobtitle,
            phone,
            website,
            industry,
            num_employees,
            annual_revenue,
            lead_status,
            lifecycle_stage,
            hubspot_owner_id,
            created_date,
            last_modified_date,
            last_activity_date,
            -- Custom properties for Pay Ready context
            property_apartment_units,
            property_portfolio_size,
            property_management_software,
            property_decision_maker_role
        FROM %(self.hubspot_database)s.%(self.hubspot_schema)s.%(self.table_mappings["contacts"])s
        WHERE 1=1
        """

        # Add filters
        if filters:
            for key, value in filters.items():
                if isinstance(value, str):
                    base_query += f" AND {key} = '{value}'"
                elif isinstance(value, list):
                    values = "','".join(value)
                    base_query += f" AND {key} IN ('{values}')"
                else:
                    base_query += f" AND {key} = {value}"

        # Add date range filtering
        if date_range:
            if "start_date" in date_range:
                base_query += (
                    f" AND created_date >= '{date_range['start_date'].isoformat()}'"
                )
            if "end_date" in date_range:
                base_query += (
                    f" AND created_date <= '{date_range['end_date'].isoformat()}'"
                )

        # Add ordering and limit
        base_query += " ORDER BY last_modified_date DESC"

        if limit:
            base_query += f" LIMIT {limit}"

        return base_query

    def _build_deals_query(
        self,
        pipeline_filters: list[str] | None,
        stage_filters: list[str] | None,
        date_range: dict[str, datetime] | None,
        limit: int | None,
    ) -> str:
        """Build SQL query for HubSpot deals"""

        base_query = """

        SELECT
            d.deal_id,
            d.deal_name,
            d.amount,
            d.close_date,
            d.create_date,
            d.last_modified_date,
            d.deal_stage,
            d.deal_pipeline,
            d.hubspot_owner_id,
            d.deal_type,
            d.lead_source,
            d.num_associated_contacts,
            -- Deal-specific properties
            d.property_apartment_units_interested,
            d.property_current_management_software,
            d.property_decision_timeline,
            d.property_budget_range,
            -- Associated company info
            c.company_name,
            c.industry,
            c.num_employees,
            c.annual_revenue as company_revenue
        FROM %(self.hubspot_database)s.%(self.hubspot_schema)s.%(self.table_mappings["deals"])s d
        LEFT JOIN %(self.hubspot_database)s.%(self.hubspot_schema)s.%(self.table_mappings["companies"])s c
            ON d.associated_company_id = c.company_id
        WHERE 1=1
        """

        # Add pipeline filters
        if pipeline_filters:
            pipelines = "','".join(pipeline_filters)
            base_query += f" AND d.deal_pipeline IN ('{pipelines}')"

        # Add stage filters
        if stage_filters:
            stages = "','".join(stage_filters)
            base_query += f" AND d.deal_stage IN ('{stages}')"

        # Add date range
        if date_range:
            if "start_date" in date_range:
                base_query += (
                    f" AND d.create_date >= '{date_range['start_date'].isoformat()}'"
                )
            if "end_date" in date_range:
                base_query += (
                    f" AND d.create_date <= '{date_range['end_date'].isoformat()}'"
                )

        base_query += " ORDER BY d.last_modified_date DESC"

        if limit:
            base_query += f" LIMIT {limit}"

        return base_query

    def _build_activities_query(
        self,
        activity_types: list[str] | None,
        contact_ids: list[str] | None,
        date_range: dict[str, datetime] | None,
        limit: int | None,
    ) -> str:
        """Build SQL query for HubSpot activities"""

        base_query = """

        SELECT
            activity_id,
            activity_type,
            activity_date,
            contact_id,
            deal_id,
            company_id,
            hubspot_owner_id,
            subject,
            body,
            outcome,
            duration_minutes,
            meeting_outcome,
            call_disposition,
            email_status,
            created_date,
            last_modified_date
        FROM %(self.hubspot_database)s.%(self.hubspot_schema)s.%(self.table_mappings["activities"])s
        WHERE 1=1
        """

        # Add activity type filters
        if activity_types:
            types = "','".join(activity_types)
            base_query += f" AND activity_type IN ('{types}')"

        # Add contact filters
        if contact_ids:
            contacts = "','".join(contact_ids)
            base_query += f" AND contact_id IN ('{contacts}')"

        # Add date range
        if date_range:
            if "start_date" in date_range:
                base_query += (
                    f" AND activity_date >= '{date_range['start_date'].isoformat()}'"
                )
            if "end_date" in date_range:
                base_query += (
                    f" AND activity_date <= '{date_range['end_date'].isoformat()}'"
                )

        base_query += " ORDER BY activity_date DESC"

        if limit:
            base_query += f" LIMIT {limit}"

        return base_query

    async def get_hubspot_data_for_ai_processing(
        self,
        data_type: str = "contacts",
        ai_context: str | None = None,
        limit: int = 1000,
    ) -> dict[str, Any]:
        """
        Get HubSpot data optimized for AI processing and analysis

        Args:
            data_type: Type of data to retrieve (contacts, deals, activities)
            ai_context: Context for AI processing (lead_scoring, churn_prediction, etc.)
            limit: Maximum records to process

        Returns:
            Dictionary with data ready for AI agents and Snowflake Cortex processing
        """
        # Placeholder implementation - will be expanded based on actual Secure Data Share structure
        logger.info(
            f"Preparing {data_type} data for AI processing with context: {ai_context}"
        )

        return {
            "data_type": data_type,
            "ai_context": ai_context,
            "status": "ready_for_implementation",
            "notes": "Awaiting HubSpot Secure Data Share configuration",
        }

    async def close(self):
        """Close Snowflake connection"""
        if self.connection:
            self.connection.close()
            self.initialized = False
            logger.info("Snowflake HubSpot connector closed")


# Global connector instance
hubspot_connector = SnowflakeHubSpotConnector()


async def get_hubspot_connector() -> SnowflakeHubSpotConnector:
    """Get the global HubSpot connector instance"""
    if not hubspot_connector.initialized:
        await hubspot_connector.initialize()
    return hubspot_connector


# Convenience functions for BI agents
async def get_recent_hubspot_contacts(
    days: int = 30, limit: int = 1000
) -> pd.DataFrame:
    """Get recent HubSpot contacts for AI analysis"""
    connector = await get_hubspot_connector()
    date_range = {
        "start_date": datetime.now() - timedelta(days=days),
        "end_date": datetime.now(),
    }
    return await connector.query_hubspot_contacts(date_range=date_range, limit=limit)


async def get_active_hubspot_deals(limit: int = 500) -> pd.DataFrame:
    """Get active HubSpot deals for pipeline analysis"""
    connector = await get_hubspot_connector()
    # Filter for non-closed stages
    stage_filters = [
        "appointmentscheduled",
        "qualifiedtobuy",
        "presentationscheduled",
        "decisionmakerboughtin",
    ]
    return await connector.query_hubspot_deals(stage_filters=stage_filters, limit=limit)


async def get_hubspot_activity_summary(
    contact_id: str, days: int = 90
) -> dict[str, Any]:
    """Get activity summary for a specific contact"""
    connector = await get_hubspot_connector()
    date_range = {
        "start_date": datetime.now() - timedelta(days=days),
        "end_date": datetime.now(),
    }

    activities_df = await connector.query_hubspot_activities(
        contact_ids=[contact_id], date_range=date_range, limit=1000
    )

    # Summarize activities
    summary = {
        "contact_id": contact_id,
        "total_activities": len(activities_df),
        "activity_breakdown": activities_df["activity_type"].value_counts().to_dict(),
        "last_activity_date": (
            activities_df["activity_date"].max() if len(activities_df) > 0 else None
        ),
        "engagement_score": len(activities_df) / days * 30,  # Activities per month
        "data_source": "snowflake_secure_share",
    }

    return summary
