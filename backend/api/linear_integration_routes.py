"""
Linear Integration API Routes for Sophia AI
Provides endpoints for Linear project management data via MCP server.
"""

"""
File Decomposition Plan (auto-generated by Phase 3)
Current size: 613 lines

Recommended decomposition:
- linear_integration_routes_core.py - Core functionality
- linear_integration_routes_utils.py - Utility functions
- linear_integration_routes_models.py - Data models
- linear_integration_routes_handlers.py - Request handlers

TODO: Implement file decomposition
"""

import json
import logging
from datetime import datetime
from typing import Any

import aiohttp
from fastapi import APIRouter, HTTPException, Query
from pydantic import BaseModel

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/api/v1/integrations/linear", tags=["linear"])


# Pydantic models for request/response
class LinearProjectSummary(BaseModel):
    id: str
    name: str
    state: str
    progress: float
    lead: str | None = None
    team: str | None = None
    start_date: str | None = None
    target_date: str | None = None
    completed_at: str | None = None
    total_issues: int = 0
    completed_issues: int = 0
    completion_rate: float = 0.0


class LinearIssueSummary(BaseModel):
    id: str
    title: str
    state: str
    priority: int
    assignee: str | None = None
    team: str | None = None
    project: str | None = None
    created_at: str | None = None
    updated_at: str | None = None
    due_date: str | None = None


class LinearTeamSummary(BaseModel):
    id: str
    name: str
    key: str
    member_count: int
    project_count: int
    total_issues: int
    active_projects: int


class LinearIntegrationHealth(BaseModel):
    status: str
    last_sync: str
    api_health: bool
    total_projects: int
    total_issues: int
    total_teams: int
    sync_errors: list[str] = []


class LinearMCPClient:
    """Client for communicating with Linear MCP server."""

    def __init__(self):
        self.mcp_url = "http://linear-mcp:3007"
        self.timeout = 30

    async def call_tool(
        self, tool_name: str, arguments: dict[str, Any]
    ) -> dict[str, Any]:
        """Call a tool on the Linear MCP server."""
        try:
            async with aiohttp.ClientSession(
                timeout=aiohttp.ClientTimeout(total=self.timeout)
            ) as session:
                payload = {
                    "method": "tools/call",
                    "params": {"name": tool_name, "arguments": arguments},
                }

                async with session.post(
                    f"{self.mcp_url}/mcp", json=payload
                ) as response:
                    if response.status == 200:
                        result = await response.json()
                        # Parse the text content from MCP response
                        if "result" in result and "content" in result["result"]:
                            content = result["result"]["content"][0]["text"]
                            return json.loads(content)
                        return result
                    else:
                        error_text = await response.text()
                        raise Exception(
                            f"MCP server error {response.status}: {error_text}"
                        )
        except Exception as e:
            logger.error(f"Error calling Linear MCP tool {tool_name}: {str(e)}")
            raise HTTPException(
                status_code=500, detail=f"Linear integration error: {str(e)}"
            )


# Initialize MCP client
linear_client = LinearMCPClient()


@router.get("/health", response_model=LinearIntegrationHealth)
async def get_linear_health():
    """Get Linear integration health status."""
    try:
        # Test connection by getting projects
        projects_result = await linear_client.call_tool("get_projects", {"limit": 1})
        total_projects = projects_result.get("total_count", 0)

        # Test getting issues for health check
        issues_result = await linear_client.call_tool("get_issues", {"limit": 1})
        total_issues = issues_result.get("total_count", 0)

        # Test getting teams
        teams_result = await linear_client.call_tool("get_teams", {})
        total_teams = teams_result.get("total_count", 0)

        return LinearIntegrationHealth(
            status="healthy",
            last_sync=datetime.now().isoformat(),
            api_health=True,
            total_projects=total_projects,
            total_issues=total_issues,
            total_teams=total_teams,
            sync_errors=[],
        )
    except Exception as e:
        logger.error(f"Linear health check failed: {str(e)}")
        return LinearIntegrationHealth(
            status="unhealthy",
            last_sync=datetime.now().isoformat(),
            api_health=False,
            total_projects=0,
            total_issues=0,
            total_teams=0,
            sync_errors=[str(e)],
        )


@router.get("/projects", response_model=list[LinearProjectSummary])
async def get_projects(
    team_id: str | None = Query(None, description="Filter by team ID"),
    state: str | None = Query(None, description="Filter by project state"),
    limit: int = Query(50, description="Maximum number of projects to return"),
):
    """Get projects from Linear."""
    try:
        arguments = {"limit": min(limit, 100)}

        if team_id:
            arguments["team_id"] = team_id
        if state:
            arguments["state"] = state

        result = await linear_client.call_tool("get_projects", arguments)

        projects = []
        for project in result.get("projects", []):
            metrics = project.get("metrics", {})

            projects.append(
                LinearProjectSummary(
                    id=project["id"],
                    name=project.get("name", "Unnamed Project"),
                    state=project.get("state", {}).get("name", "unknown"),
                    progress=project.get("progress", 0.0),
                    lead=(
                        project.get("lead", {}).get("name")
                        if project.get("lead")
                        else None
                    ),
                    team=(
                        project.get("team", {}).get("name")
                        if project.get("team")
                        else None
                    ),
                    start_date=project.get("startDate"),
                    target_date=project.get("targetDate"),
                    completed_at=project.get("completedAt"),
                    total_issues=metrics.get("total_issues", 0),
                    completed_issues=metrics.get("completed_issues", 0),
                    completion_rate=metrics.get("completion_rate", 0.0),
                )
            )

        return projects
    except Exception as e:
        logger.error(f"Error getting Linear projects: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Failed to get projects: {str(e)}")


@router.get("/projects/{project_id}")
async def get_project_details(project_id: str):
    """Get detailed information about a specific project."""
    try:
        result = await linear_client.call_tool(
            "get_project_details", {"project_id": project_id}
        )
        return result
    except Exception as e:
        logger.error(f"Error getting project details for {project_id}: {str(e)}")
        raise HTTPException(
            status_code=500, detail=f"Failed to get project details: {str(e)}"
        )


@router.get("/issues", response_model=list[LinearIssueSummary])
async def get_issues(
    team_id: str | None = Query(None, description="Filter by team ID"),
    project_id: str | None = Query(None, description="Filter by project ID"),
    assignee_id: str | None = Query(None, description="Filter by assignee ID"),
    state: str | None = Query(None, description="Filter by issue state"),
    priority: int | None = Query(None, description="Filter by priority level"),
    limit: int = Query(100, description="Maximum number of issues to return"),
):
    """Get issues from Linear."""
    try:
        arguments = {"limit": min(limit, 100)}

        if team_id:
            arguments["team_id"] = team_id
        if project_id:
            arguments["project_id"] = project_id
        if assignee_id:
            arguments["assignee_id"] = assignee_id
        if state:
            arguments["state"] = state
        if priority is not None:
            arguments["priority"] = priority

        result = await linear_client.call_tool("get_issues", arguments)

        issues = []
        for issue in result.get("issues", []):
            issues.append(
                LinearIssueSummary(
                    id=issue["id"],
                    title=issue.get("title", "Untitled Issue"),
                    state=issue.get("state", {}).get("name", "unknown"),
                    priority=issue.get("priority", 0),
                    assignee=(
                        issue.get("assignee", {}).get("name")
                        if issue.get("assignee")
                        else None
                    ),
                    team=(
                        issue.get("team", {}).get("name") if issue.get("team") else None
                    ),
                    project=(
                        issue.get("project", {}).get("name")
                        if issue.get("project")
                        else None
                    ),
                    created_at=issue.get("createdAt"),
                    updated_at=issue.get("updatedAt"),
                    due_date=issue.get("dueDate"),
                )
            )

        return issues
    except Exception as e:
        logger.error(f"Error getting Linear issues: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Failed to get issues: {str(e)}")


@router.get("/issues/{issue_id}")
async def get_issue_details(issue_id: str):
    """Get detailed information about a specific issue."""
    try:
        result = await linear_client.call_tool(
            "get_issue_details", {"issue_id": issue_id}
        )
        return result
    except Exception as e:
        logger.error(f"Error getting issue details for {issue_id}: {str(e)}")
        raise HTTPException(
            status_code=500, detail=f"Failed to get issue details: {str(e)}"
        )


@router.get("/teams", response_model=list[LinearTeamSummary])
async def get_teams(
    include_archived: bool = Query(False, description="Include archived teams"),
):
    """Get teams in the workspace."""
    try:
        arguments = {"include_archived": include_archived}

        result = await linear_client.call_tool("get_teams", arguments)

        teams = []
        for team in result.get("teams", []):
            metrics = team.get("metrics", {})

            teams.append(
                LinearTeamSummary(
                    id=team["id"],
                    name=team.get("name", "Unnamed Team"),
                    key=team.get("key", ""),
                    member_count=metrics.get("member_count", 0),
                    project_count=metrics.get("project_count", 0),
                    total_issues=metrics.get("total_issues", 0),
                    active_projects=metrics.get("active_projects", 0),
                )
            )

        return teams
    except Exception as e:
        logger.error(f"Error getting Linear teams: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Failed to get teams: {str(e)}")


@router.get("/teams/{team_id}/members")
async def get_team_members(team_id: str):
    """Get members of a specific team."""
    try:
        result = await linear_client.call_tool("get_team_members", {"team_id": team_id})
        return result
    except Exception as e:
        logger.error(f"Error getting team members for {team_id}: {str(e)}")
        raise HTTPException(
            status_code=500, detail=f"Failed to get team members: {str(e)}"
        )


@router.get("/search/issues", response_model=list[LinearIssueSummary])
async def search_issues(
    query: str | None = Query(
        None, description="Search query for issue titles and descriptions"
    ),
    team_id: str | None = Query(None, description="Limit search to specific team"),
    assignee_id: str | None = Query(None, description="Filter by assignee ID"),
    state: str | None = Query(None, description="Filter by issue state"),
    limit: int = Query(50, description="Maximum number of issues to return"),
):
    """Search for issues with various filters."""
    try:
        arguments = {"limit": min(limit, 100)}

        if query:
            arguments["query"] = query
        if team_id:
            arguments["team_id"] = team_id
        if assignee_id:
            arguments["assignee_id"] = assignee_id
        if state:
            arguments["state"] = state

        result = await linear_client.call_tool("search_issues", arguments)

        issues = []
        for issue in result.get("issues", []):
            issues.append(
                LinearIssueSummary(
                    id=issue["id"],
                    title=issue.get("title", "Untitled Issue"),
                    state=issue.get("state", {}).get("name", "unknown"),
                    priority=issue.get("priority", 0),
                    assignee=(
                        issue.get("assignee", {}).get("name")
                        if issue.get("assignee")
                        else None
                    ),
                    team=(
                        issue.get("team", {}).get("name") if issue.get("team") else None
                    ),
                    project=(
                        issue.get("project", {}).get("name")
                        if issue.get("project")
                        else None
                    ),
                    created_at=issue.get("createdAt"),
                    updated_at=issue.get("updatedAt"),
                    due_date=issue.get("dueDate"),
                )
            )

        return issues
    except Exception as e:
        logger.error(f"Error searching Linear issues: {str(e)}")
        raise HTTPException(
            status_code=500, detail=f"Failed to search issues: {str(e)}"
        )


@router.get("/users/{user_id}/issues", response_model=list[LinearIssueSummary])
async def get_user_issues(
    user_id: str,
    state: str | None = Query(None, description="Filter by issue state"),
    team_id: str | None = Query(None, description="Filter by team ID"),
):
    """Get issues assigned to a specific user."""
    try:
        arguments = {"user_id": user_id}

        if state:
            arguments["state"] = state
        if team_id:
            arguments["team_id"] = team_id

        result = await linear_client.call_tool("get_user_issues", arguments)

        issues = []
        for issue in result.get("issues", []):
            issues.append(
                LinearIssueSummary(
                    id=issue["id"],
                    title=issue.get("title", "Untitled Issue"),
                    state=issue.get("state", {}).get("name", "unknown"),
                    priority=issue.get("priority", 0),
                    assignee=user_id,
                    team=(
                        issue.get("team", {}).get("name") if issue.get("team") else None
                    ),
                    project=(
                        issue.get("project", {}).get("name")
                        if issue.get("project")
                        else None
                    ),
                    created_at=issue.get("createdAt"),
                    updated_at=issue.get("updatedAt"),
                    due_date=issue.get("dueDate"),
                )
            )

        return issues
    except Exception as e:
        logger.error(f"Error getting issues for user {user_id}: {str(e)}")
        raise HTTPException(
            status_code=500, detail=f"Failed to get user issues: {str(e)}"
        )


@router.get("/users")
async def get_workspace_users(
    include_guests: bool = Query(False, description="Include guest users"),
):
    """Get users in the workspace."""
    try:
        arguments = {"include_guests": include_guests}

        result = await linear_client.call_tool("get_workspace_users", arguments)
        return result
    except Exception as e:
        logger.error(f"Error getting Linear users: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Failed to get users: {str(e)}")


@router.get("/milestones")
async def get_milestones(
    project_id: str | None = Query(None, description="Filter by project ID"),
    team_id: str | None = Query(None, description="Filter by team ID"),
    limit: int = Query(20, description="Maximum number of milestones to return"),
):
    """Get milestones for projects or teams."""
    try:
        arguments = {"limit": min(limit, 50)}

        if project_id:
            arguments["project_id"] = project_id
        if team_id:
            arguments["team_id"] = team_id

        result = await linear_client.call_tool("get_milestones", arguments)
        return result
    except Exception as e:
        logger.error(f"Error getting Linear milestones: {str(e)}")
        raise HTTPException(
            status_code=500, detail=f"Failed to get milestones: {str(e)}"
        )


@router.get("/dashboard/summary")
async def get_dashboard_summary():
    """Get summary data for executive dashboard."""
    try:
        # Get projects overview
        projects_result = await linear_client.call_tool("get_projects", {"limit": 100})
        projects = projects_result.get("projects", [])

        # Get issues overview
        issues_result = await linear_client.call_tool("get_issues", {"limit": 100})
        issues = issues_result.get("issues", [])

        # Get teams overview
        teams_result = await linear_client.call_tool("get_teams", {})
        teams = teams_result.get("teams", [])

        # Calculate summary metrics
        total_projects = len(projects)
        active_projects = len(
            [
                p
                for p in projects
                if p.get("state", {}).get("name") not in ["completed", "canceled"]
            ]
        )
        completed_projects = len(
            [p for p in projects if p.get("state", {}).get("name") == "completed"]
        )

        total_issues = len(issues)
        completed_issues = len(
            [i for i in issues if i.get("state", {}).get("type") == "completed"]
        )
        active_issues = total_issues - completed_issues

        # Priority distribution
        priority_distribution = {
            "urgent": 0,
            "high": 0,
            "normal": 0,
            "low": 0,
            "none": 0,
        }
        for issue in issues:
            priority = issue.get("priority", 0)
            if priority == 1:
                priority_distribution["urgent"] += 1
            elif priority == 2:
                priority_distribution["high"] += 1
            elif priority == 3:
                priority_distribution["normal"] += 1
            elif priority == 4:
                priority_distribution["low"] += 1
            else:
                priority_distribution["none"] += 1

        # Team metrics
        total_teams = len(teams)
        active_teams = len([t for t in teams if not t.get("isArchived", False)])

        return {
            "total_projects": total_projects,
            "active_projects": active_projects,
            "completed_projects": completed_projects,
            "project_completion_rate": (
                (completed_projects / total_projects * 100) if total_projects > 0 else 0
            ),
            "total_issues": total_issues,
            "active_issues": active_issues,
            "completed_issues": completed_issues,
            "issue_completion_rate": (
                (completed_issues / total_issues * 100) if total_issues > 0 else 0
            ),
            "priority_distribution": priority_distribution,
            "total_teams": total_teams,
            "active_teams": active_teams,
            "sync_time": datetime.now().isoformat(),
            "health_status": "healthy",
        }
    except Exception as e:
        logger.error(f"Error getting dashboard summary: {str(e)}")
        raise HTTPException(
            status_code=500, detail=f"Failed to get dashboard summary: {str(e)}"
        )


# Helper functions
def _map_linear_priority(priority: int) -> str:
    """Map Linear priority number to human-readable string."""
    priority_map = {0: "No Priority", 1: "Urgent", 2: "High", 3: "Normal", 4: "Low"}
    return priority_map.get(priority, "Unknown")


def _calculate_project_health(project: dict[str, Any]) -> str:
    """Calculate project health based on various metrics."""
    # This is a simplified health calculation
    # In practice, you'd want more sophisticated logic

    progress = project.get("progress", 0)
    state = project.get("state", {}).get("name", "")

    if state in ["completed"]:
        return "completed"
    elif state in ["canceled"]:
        return "canceled"
    elif progress >= 0.8:
        return "on_track"
    elif progress >= 0.5:
        return "at_risk"
    else:
        return "behind"


def _calculate_team_velocity(team_data: dict[str, Any]) -> float:
    """Calculate team velocity based on issue completion."""
    # This would typically look at historical data
    # For now, return a placeholder calculation

    metrics = team_data.get("metrics", {})
    total_issues = metrics.get("total_issues", 0)

    if total_issues == 0:
        return 0.0

    # Simplified velocity calculation
    # In practice, you'd want to look at completed issues over time
    return min(total_issues * 0.1, 10.0)  # Cap at 10 for demo purposes
