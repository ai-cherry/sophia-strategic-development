"""
Snowflake MCP Client
Lightweight HTTP client for communication with Snowflake MCP server.
"""

from backend.services.unified_memory_service_v3 import UnifiedMemoryServiceV3
import asyncio
import json
import time
import uuid
from collections.abc import AsyncIterator
from typing import Any

import httpx
import structlog
from pydantic import BaseModel, Field

from backend.core.config import get_config_value

logger = structlog.get_logger(__name__)


class MCPRequest(BaseModel):
    """MCP request model"""

    tool: str
    parameters: dict[str, Any]
    trace_id: str = Field(default_factory=lambda: f"mcp-{uuid.uuid4().hex[:16]}")
    timeout: int = 120


class MCPResponse(BaseModel):
    """MCP response model"""

    status: str
    operation_id: str | None = None
    response: str | None = None
    usage: dict[str, Any] | None = None
    stream: bool = False
    stream_id: str | None = None
    server_id: str | None = None
    model: str | None = None
    error: str | None = None


class RetryConfig(BaseModel):
    """Retry configuration"""

    max_attempts: int = 3
    initial_delay: float = 0.5
    max_delay: float = 5.0
    exponential_base: float = 2.0


class SnowflakeMCPClient:
    """
    HTTP client for Snowflake MCP server communication.
    Handles PAT authentication, retries, and streaming responses.
    """

    def __init__(
        self,
        base_url: str | None = None,
        pat: str | None = None,
        timeout: int = 120,
        retry_config: RetryConfig | None = None,
    ):
        self.base_url = base_url or get_config_value(
            "snowflake_mcp_url", "https://mcp-snowflake.sophia-ai.com"
        )
        self.pat = pat or self._get_pat()
        self.timeout = timeout
        self.retry_config = retry_config or RetryConfig()

        # HTTP client with connection pooling
        self.client = httpx.AsyncClient(
            base_url=self.base_url,
            timeout=httpx.Timeout(timeout),
            headers={
                "Authorization": f"Bearer {self.pat}",
                "Content-Type": "application/json",
                "User-Agent": "Sophia-AI/1.0",
            },
            limits=httpx.Limits(max_keepalive_connections=10, max_connections=20),
        )

        logger.info("SnowflakeMCPClient initialized", base_url=self.base_url)

    def _get_pat(self) -> str:
        """Get PAT from configuration."""
        environment = get_config_value("environment", "prod")
        pat_key = f"snowflake_pat_{environment}"

        pat = get_config_value(pat_key)
        if not pat:
            # Try without environment suffix
            pat = get_config_value("snowflake_pat")

        if not pat:
            raise ValueError(
# REMOVED: Snowflake dependencyured for environment: {environment}"
            )

        return pat

    async def execute_cortex(self, request: dict[str, Any]) -> dict[str, Any]:
        """
        Execute Cortex operation via MCP server.
        Handles both synchronous and asynchronous responses.
        """
        # Convert dict to MCPRequest if needed
        if isinstance(request, dict):
            mcp_request = MCPRequest(**request)
        else:
            mcp_request = request

        logger.info(
            "Executing Cortex via MCP",
            tool=mcp_request.tool,
            trace_id=mcp_request.trace_id,
        )

        # Execute with retry
        response = await self._execute_with_retry(
            "POST", f"/tool/{mcp_request.tool}/invoke", json=mcp_request.model_dump()
        )

        # Handle 202 Accepted (async operation)
        if response.status_code == 202:
            operation_id = response.json().get("operation_id")
            if not operation_id:
                raise ValueError("No operation_id in 202 response")

            logger.info(
                "MCP operation accepted, polling for result",
                operation_id=operation_id,
                trace_id=mcp_request.trace_id,
            )

            # Poll for result
            result = await self._poll_operation(operation_id, mcp_request.timeout)
            return result

        # Handle 200 OK (sync response)
        elif response.status_code == 200:
            return response.json()

        else:
            error_detail = response.json().get("error", response.text)
            raise httpx.HTTPStatusError(
                f"MCP request failed: {error_detail}",
                request=response.request,
                response=response,
            )

    async def _execute_with_retry(
        self, method: str, path: str, **kwargs
    ) -> httpx.Response:
        """Execute HTTP request with exponential backoff retry."""
        last_error = None

        for attempt in range(self.retry_config.max_attempts):
            try:
                response = await self.client.request(method, path, **kwargs)

                # Don't retry on 4xx errors (client errors)
                if 400 <= response.status_code < 500:
                    return response

                response.raise_for_status()
                return response

            except (
                httpx.TimeoutException,
                httpx.NetworkError,
                httpx.HTTPStatusError,
            ) as e:
                last_error = e

                if attempt < self.retry_config.max_attempts - 1:
                    delay = min(
                        self.retry_config.initial_delay
                        * (self.retry_config.exponential_base**attempt),
                        self.retry_config.max_delay,
                    )

                    logger.warning(
                        "MCP request failed, retrying",
                        method=method,
                        path=path,
                        attempt=attempt + 1,
                        delay=delay,
                        error=str(e),
                    )

                    await asyncio.sleep(delay)
                else:
                    logger.error(
                        "MCP request failed after all retries",
                        method=method,
                        path=path,
                        attempts=self.retry_config.max_attempts,
                        error=str(e),
                    )

        raise last_error

    async def _poll_operation(self, operation_id: str, timeout: int) -> dict[str, Any]:
        """Poll for async operation result."""
        start_time = time.time()
        poll_interval = 1.0  # Start with 1 second
        max_poll_interval = 5.0

        while time.time() - start_time < timeout:
            response = await self._execute_with_retry(
                "GET", f"/operation/{operation_id}"
            )

            result = response.json()
            status = result.get("status")

            if status == "COMPLETED":
                return result.get("result", {})
            elif status == "FAILED":
                raise RuntimeError(
                    f"MCP operation failed: {result.get('error', 'Unknown error')}"
                )
            elif status in ["PENDING", "RUNNING"]:
                # Continue polling
                await asyncio.sleep(poll_interval)
                # Exponential backoff for polling
                poll_interval = min(poll_interval * 1.5, max_poll_interval)
            else:
                raise ValueError(f"Unknown operation status: {status}")

        raise TimeoutError(
            f"Operation {operation_id} timed out after {timeout} seconds"
        )

    async def stream_response(self, stream_id: str) -> AsyncIterator[dict[str, Any]]:
        """Stream response chunks from MCP server."""
        async with self.client.stream(
            "GET", f"/stream/{stream_id}", headers={"Accept": "text/event-stream"}
        ) as response:
            async for line in response.aiter_lines():
                if line.startswith("data: "):
                    try:
                        chunk = json.loads(line[6:])
                        yield chunk
                    except json.JSONDecodeError:
                        logger.warning("Failed to parse SSE chunk", line=line)
                        continue
                elif line == "data: [DONE]":
                    break

    async def health_check(self) -> dict[str, Any]:
        """Check MCP server health."""
        try:
            response = await self._execute_with_retry(
                "GET", "/health/live", timeout=5.0
            )

            if response.status_code == 200:
                return {
                    "status": "healthy",
                    "latency_ms": response.elapsed.total_seconds() * 1000,
                    **response.json(),
                }
            else:
                return {
                    "status": "unhealthy",
                    "status_code": response.status_code,
                    "error": response.text,
                }

        except Exception as e:
            return {"status": "unhealthy", "error": str(e)}

    async def get_capabilities(self) -> dict[str, Any]:
        """Get MCP server capabilities."""
        response = await self._execute_with_retry("GET", "/capabilities")
        return response.json()

    async def close(self):
        """Close the HTTP client."""
        await self.client.aclose()

    async def __aenter__(self):
        """Async context manager entry."""
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Async context manager exit."""
        await self.close()


class Session:
    """MCP session for connection pooling compatibility."""

    def __init__(self, client: SnowflakeMCPClient):
        self.client = client
        self.session_id = uuid.uuid4().hex

    async def execute_async(self, request: dict[str, Any]) -> dict[str, Any]:
        """Execute request through the session."""
        return await self.client.execute_cortex(request)
