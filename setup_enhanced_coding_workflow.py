#!/usr/bin/env python3
"""
Setup Enhanced Coding Workflow for Sophia AI
Implements capabilities similar to Zencoder and cursor-companion
"""

"""
File Decomposition Plan (auto-generated by Phase 3)
Current size: 923 lines

Recommended decomposition:
- setup_enhanced_coding_workflow_core.py - Core functionality
- setup_enhanced_coding_workflow_utils.py - Utility functions  
- setup_enhanced_coding_workflow_models.py - Data models
- setup_enhanced_coding_workflow_handlers.py - Request handlers

TODO: Implement file decomposition
"""

import os
import json
import subprocess
from pathlib import Path


def setup_enhanced_workflow():
    """Setup enhanced coding workflow capabilities"""
    print("üöÄ Setting up Sophia AI Enhanced Coding Workflow...")
    print("   Combining Zencoder + cursor-companion + Sophia AI capabilities")
    print("=" * 70)

    # 1. Create enhanced workflow structure
    print("\nüìÅ Creating enhanced workspace structure...")
    create_workspace_structure()

    # 2. Install VS Code extension preparation
    print("\nüíª Preparing VS Code integration...")
    prepare_vscode_integration()

    # 3. Create Chrome extension manifest
    print("\nüåê Creating Chrome extension for platform integration...")
    create_chrome_extension()

    # 4. Setup prompt and rule management
    print("\nüìù Setting up prompt and rule management...")
    setup_prompt_management()

    # 5. Create workflow automation scripts
    print("\nü§ñ Creating workflow automation...")
    create_workflow_automation()

    # 6. Test integration
    print("\nüß™ Testing integration...")
    test_integration()

    print("\n‚úÖ Enhanced Coding Workflow setup complete!")
    show_usage_examples()


def create_workspace_structure():
    """Create enhanced workspace structure"""
    directories = [
        ".sophia",
        ".sophia/prompts",
        ".sophia/rules",
        ".sophia/context",
        ".sophia/workflows",
        ".sophia/integrations",
        "sophia-vscode-extension",
        "sophia-chrome-extension",
    ]

    for directory in directories:
        Path(directory).mkdir(exist_ok=True)
        print(f"  ‚úÖ Created: {directory}")


def prepare_vscode_integration():
    """Prepare VS Code extension"""
    # Create extension entry point
    extension_code = """
import * as vscode from 'vscode';
import axios from 'axios';

export function activate(context: vscode.ExtensionContext) {
    console.log('Sophia AI Assistant activated!');
    
    // Register commands
    registerCommands(context);
    
    // Setup status bar
    setupStatusBar();
    
    // Initialize chat panel
    initializeChatPanel(context);
}

function registerCommands(context: vscode.ExtensionContext) {
    // Generate Code command
    const generateCode = vscode.commands.registerCommand('sophia.generateCode', async () => {
        const editor = vscode.window.activeTextEditor;
        if (!editor) return;
        
        const selection = editor.selection;
        const selectedText = editor.document.getText(selection);
        
        const prompt = await vscode.window.showInputBox({
            prompt: 'What code would you like to generate?',
            placeHolder: 'e.g., Create a React component for user authentication'
        });
        
        if (prompt) {
            await generateCodeWithSophia(prompt, selectedText, editor);
        }
    });
    
    // Chat with Sophia command
    const chatWithSophia = vscode.commands.registerCommand('sophia.chatWithSophia', () => {
        SophiaChatPanel.createOrShow(context.extensionUri);
    });
    
    // Business Analysis command
    const businessAnalysis = vscode.commands.registerCommand('sophia.businessAnalysis', async () => {
        const editor = vscode.window.activeTextEditor;
        if (!editor) return;
        
        const code = editor.document.getText();
        await analyzeBusinessImpact(code);
    });
    
    context.subscriptions.push(generateCode, chatWithSophia, businessAnalysis);
}

async function generateCodeWithSophia(prompt: string, context: string, editor: vscode.TextEditor) {
    try {
        const config = vscode.workspace.getConfiguration('sophia');
        const apiEndpoint = config.get('apiEndpoint', 'http://localhost:8000');
        
        const response = await axios.post(`${apiEndpoint}/api/chat/enhanced`, {
            message: `Generate code: ${prompt}\\n\\nContext: ${context}`,
            context: 'coding',
            preferred_model: config.get('claudeModel', 'claude-3-5-sonnet-20241119')
        });
        
        const generatedCode = response.data.response;
        
        // Insert generated code
        const position = editor.selection.active;
        editor.edit(editBuilder => {
            editBuilder.insert(position, generatedCode);
        });
        
        vscode.window.showInformationMessage('Code generated by Sophia AI!');
        
    } catch (error) {
        vscode.window.showErrorMessage(`Error: ${error.message}`);
    }
}

class SophiaChatPanel {
    public static currentPanel: SophiaChatPanel | undefined;
    
    public static createOrShow(extensionUri: vscode.Uri) {
        const column = vscode.window.activeTextEditor
            ? vscode.window.activeTextEditor.viewColumn
            : undefined;
        
        if (SophiaChatPanel.currentPanel) {
            SophiaChatPanel.currentPanel._panel.reveal(column);
            return;
        }
        
        const panel = vscode.window.createWebviewPanel(
            'sophiaChat',
            'Sophia AI Chat',
            column || vscode.ViewColumn.One,
            {
                enableScripts: true,
                localResourceRoots: [extensionUri]
            }
        );
        
        SophiaChatPanel.currentPanel = new SophiaChatPanel(panel, extensionUri);
    }
    
    private constructor(private readonly _panel: vscode.WebviewPanel, extensionUri: vscode.Uri) {
        this._panel.webview.html = this._getHtmlForWebview();
        
        this._panel.onDidDispose(() => {
            SophiaChatPanel.currentPanel = undefined;
        });
        
        this._panel.webview.onDidReceiveMessage(
            async message => {
                switch (message.command) {
                    case 'sendMessage':
                        await this.handleChatMessage(message.text);
                        break;
                }
            }
        );
    }
    
    private async handleChatMessage(message: string) {
        try {
            const config = vscode.workspace.getConfiguration('sophia');
            const apiEndpoint = config.get('apiEndpoint', 'http://localhost:8000');
            
            const response = await axios.post(`${apiEndpoint}/api/chat/enhanced`, {
                message: message,
                context: 'general'
            });
            
            this._panel.webview.postMessage({
                command: 'displayResponse',
                response: response.data.response
            });
            
        } catch (error) {
            this._panel.webview.postMessage({
                command: 'displayError',
                error: error.message
            });
        }
    }
    
    private _getHtmlForWebview(): string {
        return `
            <!DOCTYPE html>
            <html>
            <head>
                <meta charset="UTF-8">
                <title>Sophia AI Chat</title>
                <style>
                    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; }
                    .chat-container { height: 100vh; display: flex; flex-direction: column; }
                    .messages { flex: 1; overflow-y: auto; padding: 20px; }
                    .input-area { padding: 20px; border-top: 1px solid #e1e4e8; }
                    .message { margin-bottom: 15px; padding: 10px; border-radius: 8px; }
                    .user-message { background: #0366d6; color: white; margin-left: 20%; }
                    .ai-message { background: #f6f8fa; border: 1px solid #e1e4e8; margin-right: 20%; }
                </style>
            </head>
            <body>
                <div class="chat-container">
                    <div class="messages" id="messages">
                        <div class="ai-message">
                            <strong>Sophia AI:</strong> Hello! I'm your advanced AI coding assistant with business intelligence. How can I help you today?
                        </div>
                    </div>
                    <div class="input-area">
                        <input type="text" id="messageInput" placeholder="Ask Sophia AI anything..." style="width: 70%; padding: 10px;">
                        <button onclick="sendMessage()" style="padding: 10px 20px; margin-left: 10px;">Send</button>
                    </div>
                </div>
                <script>
                    const vscode = acquireVsCodeApi();
                    
                    function sendMessage() {
                        const input = document.getElementById('messageInput');
                        const message = input.value.trim();
                        if (!message) return;
                        
                        displayMessage(message, 'user');
                        input.value = '';
                        
                        vscode.postMessage({
                            command: 'sendMessage',
                            text: message
                        });
                    }
                    
                    function displayMessage(text, sender) {
                        const messages = document.getElementById('messages');
                        const messageDiv = document.createElement('div');
                        messageDiv.className = sender === 'user' ? 'user-message message' : 'ai-message message';
                        messageDiv.innerHTML = `<strong>${sender === 'user' ? 'You' : 'Sophia AI'}:</strong> ${text}`;
                        messages.appendChild(messageDiv);
                        messages.scrollTop = messages.scrollHeight;
                    }
                    
                    window.addEventListener('message', event => {
                        const message = event.data;
                        switch (message.command) {
                            case 'displayResponse':
                                displayMessage(message.response, 'ai');
                                break;
                            case 'displayError':
                                displayMessage(`Error: ${message.error}`, 'ai');
                                break;
                        }
                    });
                    
                    document.getElementById('messageInput').addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') sendMessage();
                    });
                </script>
            </body>
            </html>
        `;
    }
}

export function deactivate() {}
"""

    extension_file = Path("sophia-vscode-extension/src/extension.ts")
    extension_file.parent.mkdir(exist_ok=True)
    with open(extension_file, "w") as f:
        f.write(extension_code)

    print("  ‚úÖ VS Code extension prepared")


def create_chrome_extension():
    """Create Chrome extension for platform integration"""
    manifest = {
        "manifest_version": 3,
        "name": "Sophia AI Platform Integration",
        "version": "1.0.0",
        "description": "Integrate Sophia AI with GitHub, Jira, Linear, and other platforms",
        "permissions": ["activeTab", "storage", "contextMenus", "notifications"],
        "host_permissions": [
            "https://github.com/*",
            "https://*.atlassian.net/*",
            "https://linear.app/*",
            "https://app.linear.app/*",
            "https://slack.com/*",
            "http://localhost:8000/*",
        ],
        "content_scripts": [
            {
                "matches": [
                    "https://github.com/*",
                    "https://*.atlassian.net/*",
                    "https://linear.app/*",
                    "https://app.linear.app/*",
                ],
                "js": ["content.js"],
            }
        ],
        "background": {"service_worker": "background.js"},
        "action": {
            "default_popup": "popup.html",
            "default_title": "Sophia AI Assistant",
        },
        "icons": {
            "16": "icons/sophia-16.png",
            "48": "icons/sophia-48.png",
            "128": "icons/sophia-128.png",
        },
    }

    # Content script for platform integration
    content_script = """
// Sophia AI Platform Integration Content Script
(function() {
    console.log('Sophia AI Platform Integration loaded');
    
    // Add Sophia AI button to GitHub issues
    if (window.location.hostname === 'github.com') {
        addGitHubIntegration();
    }
    
    // Add Sophia AI button to Linear issues
    if (window.location.hostname.includes('linear.app')) {
        addLinearIntegration();
    }
    
    // Add Sophia AI button to Jira issues
    if (window.location.hostname.includes('atlassian.net')) {
        addJiraIntegration();
    }
    
    function addGitHubIntegration() {
        const issueHeader = document.querySelector('.gh-header-actions');
        if (issueHeader && !document.querySelector('.sophia-ai-button')) {
            const sophiaButton = createSophiaButton('Send to Sophia AI', () => {
                const issueData = extractGitHubIssueData();
                sendToSophiaAI('github', issueData);
            });
            issueHeader.appendChild(sophiaButton);
        }
    }
    
    function addLinearIntegration() {
        // Wait for Linear to load
        setTimeout(() => {
            const issueActions = document.querySelector('[data-testid="issue-actions"]');
            if (issueActions && !document.querySelector('.sophia-ai-button')) {
                const sophiaButton = createSophiaButton('Sophia AI', () => {
                    const issueData = extractLinearIssueData();
                    sendToSophiaAI('linear', issueData);
                });
                issueActions.appendChild(sophiaButton);
            }
        }, 2000);
    }
    
    function createSophiaButton(text, onClick) {
        const button = document.createElement('button');
        button.textContent = text;
        button.className = 'sophia-ai-button';
        button.style.cssText = `
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            margin-left: 8px;
            transition: all 0.3s ease;
        `;
        
        button.addEventListener('click', onClick);
        button.addEventListener('mouseover', () => {
            button.style.transform = 'translateY(-2px)';
            button.style.boxShadow = '0 4px 8px rgba(0,0,0,0.2)';
        });
        button.addEventListener('mouseout', () => {
            button.style.transform = 'translateY(0)';
            button.style.boxShadow = 'none';
        });
        
        return button;
    }
    
    function extractGitHubIssueData() {
        return {
            title: document.querySelector('.js-issue-title')?.textContent?.trim(),
            description: document.querySelector('.comment-body')?.textContent?.trim(),
            labels: Array.from(document.querySelectorAll('.IssueLabel')).map(l => l.textContent.trim()),
            assignee: document.querySelector('.assignee')?.textContent?.trim(),
            url: window.location.href
        };
    }
    
    function extractLinearIssueData() {
        return {
            title: document.querySelector('[data-testid="issue-title"]')?.textContent?.trim(),
            description: document.querySelector('[data-testid="issue-description"]')?.textContent?.trim(),
            status: document.querySelector('[data-testid="issue-status"]')?.textContent?.trim(),
            assignee: document.querySelector('[data-testid="issue-assignee"]')?.textContent?.trim(),
            url: window.location.href
        };
    }
    
    function sendToSophiaAI(platform, data) {
        // Show notification
        const notification = document.createElement('div');
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: #28a745;
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            z-index: 10000;
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
        `;
        notification.textContent = `Sending to Sophia AI...`;
        document.body.appendChild(notification);
        
        // Send to background script
        chrome.runtime.sendMessage({
            action: 'sendToSophia',
            platform: platform,
            data: data
        }, (response) => {
            notification.textContent = response.success ? 
                '‚úÖ Sent to Sophia AI!' : 
                '‚ùå Failed to send to Sophia AI';
            
            setTimeout(() => {
                notification.remove();
            }, 3000);
        });
    }
})();
"""

    # Background script
    background_script = """
// Sophia AI Background Script
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
    if (request.action === 'sendToSophia') {
        sendToSophiaAI(request.platform, request.data)
            .then(result => sendResponse({success: true, result}))
            .catch(error => sendResponse({success: false, error: error.message}));
        return true; // Required for async response
    }
});

async function sendToSophiaAI(platform, data) {
    try {
        const response = await fetch('http://localhost:8000/api/platform-integration', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                platform: platform,
                data: data,
                action: 'context_import'
            })
        });
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        return await response.json();
    } catch (error) {
        console.error('Failed to send to Sophia AI:', error);
        throw error;
    }
}

// Context menu integration
chrome.contextMenus.create({
    id: 'sendToSophia',
    title: 'Send to Sophia AI',
    contexts: ['selection']
});

chrome.contextMenus.onClicked.addListener((info, tab) => {
    if (info.menuItemId === 'sendToSophia') {
        chrome.tabs.sendMessage(tab.id, {
            action: 'sendSelection',
            text: info.selectionText
        });
    }
});
"""

    # Create Chrome extension files
    chrome_dir = Path("sophia-chrome-extension")

    with open(chrome_dir / "manifest.json", "w") as f:
        json.dump(manifest, f, indent=2)

    with open(chrome_dir / "content.js", "w") as f:
        f.write(content_script)

    with open(chrome_dir / "background.js", "w") as f:
        f.write(background_script)

    # Create popup HTML
    popup_html = """
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <style>
        body { width: 300px; padding: 20px; font-family: -apple-system, sans-serif; }
        .header { text-align: center; margin-bottom: 20px; }
        .logo { font-size: 24px; font-weight: bold; color: #667eea; }
        .button { width: 100%; padding: 10px; margin: 5px 0; border: none; border-radius: 6px; cursor: pointer; }
        .primary { background: #667eea; color: white; }
        .secondary { background: #f1f3f4; color: #333; }
    </style>
</head>
<body>
    <div class="header">
        <div class="logo">ü§ñ Sophia AI</div>
        <p>Advanced AI Coding Assistant</p>
    </div>
    
    <button class="button primary" id="openChat">Open Chat</button>
    <button class="button secondary" id="checkStatus">Check Status</button>
    <button class="button secondary" id="settings">Settings</button>
    
    <div id="status" style="margin-top: 15px; padding: 10px; border-radius: 4px; font-size: 12px;"></div>
    
    <script>
        document.getElementById('openChat').addEventListener('click', () => {
            chrome.tabs.create({url: 'http://localhost:3000'});
        });
        
        document.getElementById('checkStatus').addEventListener('click', async () => {
            const status = document.getElementById('status');
            status.textContent = 'Checking...';
            
            try {
                const response = await fetch('http://localhost:8000/health');
                if (response.ok) {
                    status.style.background = '#d4edda';
                    status.style.color = '#155724';
                    status.textContent = '‚úÖ Sophia AI is online and ready!';
                } else {
                    throw new Error('Not responding');
                }
            } catch (error) {
                status.style.background = '#f8d7da';
                status.style.color = '#721c24';
                status.textContent = '‚ùå Sophia AI is offline';
            }
        });
        
        // Check status on load
        document.getElementById('checkStatus').click();
    </script>
</body>
</html>
"""

    with open(chrome_dir / "popup.html", "w") as f:
        f.write(popup_html)

    print("  ‚úÖ Chrome extension created")


def setup_prompt_management():
    """Setup prompt and rule management system"""
    # Create CLI tool for prompt management
    cli_tool = '''#!/usr/bin/env python3
"""
Sophia AI Prompt and Rule Management CLI
Similar to cursor-companion but integrated with Sophia AI
"""

import json
import sys
import argparse
from pathlib import Path

class SophiaPromptManager:
    def __init__(self):
        self.workspace_root = Path.cwd()
        self.sophia_dir = self.workspace_root / ".sophia"
        self.prompts_dir = self.sophia_dir / "prompts"
        self.rules_dir = self.sophia_dir / "rules"
    
    def list_prompts(self):
        """List available prompts"""
        if not self.prompts_dir.exists():
            print("No prompts directory found. Run 'sophia init' first.")
            return
        
        prompts = list(self.prompts_dir.glob("*.json"))
        if not prompts:
            print("No prompts installed.")
            return
        
        print("üìù Installed Prompts:")
        for prompt_file in prompts:
            with open(prompt_file, 'r') as f:
                data = json.load(f)
            print(f"  ‚Ä¢ {prompt_file.stem}: {data.get('description', 'No description')}")
    
    def list_rules(self):
        """List available rules"""
        if not self.rules_dir.exists():
            print("No rules directory found. Run 'sophia init' first.")
            return
        
        rules = list(self.rules_dir.glob("*.json"))
        if not rules:
            print("No rules installed.")
            return
        
        print("üìã Installed Rules:")
        for rule_file in rules:
            with open(rule_file, 'r') as f:
                data = json.load(f)
            print(f"  ‚Ä¢ {rule_file.stem}: {data.get('description', 'No description')}")
    
    def show_prompt(self, name):
        """Show prompt details"""
        prompt_file = self.prompts_dir / f"{name}.json"
        if not prompt_file.exists():
            print(f"Prompt '{name}' not found.")
            return
        
        with open(prompt_file, 'r') as f:
            data = json.load(f)
        
        print(f"üìù Prompt: {name}")
        print(f"Description: {data.get('description', 'No description')}")
        print("\\nTemplate:")
        print(data.get('template', 'No template'))
    
    def create_prompt(self, name, description, template):
        """Create a new prompt"""
        prompt_data = {
            "name": name,
            "description": description,
            "template": template,
            "created": "2024-01-01T00:00:00Z",
            "version": "1.0.0"
        }
        
        prompt_file = self.prompts_dir / f"{name}.json"
        with open(prompt_file, 'w') as f:
            json.dump(prompt_data, f, indent=2)
        
        print(f"‚úÖ Created prompt: {name}")

def main():
    parser = argparse.ArgumentParser(description="Sophia AI Prompt Manager")
    subparsers = parser.add_subparsers(dest="command", help="Available commands")
    
    # List commands
    list_parser = subparsers.add_parser("list", help="List prompts or rules")
    list_parser.add_argument("type", choices=["prompts", "rules"], help="What to list")
    
    # Show command
    show_parser = subparsers.add_parser("show", help="Show prompt details")
    show_parser.add_argument("name", help="Prompt name")
    
    # Create command
    create_parser = subparsers.add_parser("create", help="Create new prompt")
    create_parser.add_argument("name", help="Prompt name")
    create_parser.add_argument("description", help="Prompt description")
    create_parser.add_argument("template", help="Prompt template")
    
    args = parser.parse_args()
    manager = SophiaPromptManager()
    
    if args.command == "list":
        if args.type == "prompts":
            manager.list_prompts()
        else:
            manager.list_rules()
    elif args.command == "show":
        manager.show_prompt(args.name)
    elif args.command == "create":
        manager.create_prompt(args.name, args.description, args.template)
    else:
        parser.print_help()

if __name__ == "__main__":
    main()
'''

    with open("sophia_prompt_manager.py", "w") as f:
        f.write(cli_tool)

    os.chmod("sophia_prompt_manager.py", 0o755)

    print("  ‚úÖ Prompt management CLI created")


def create_workflow_automation():
    """Create workflow automation scripts"""
    # Create workflow runner
    workflow_runner = '''#!/usr/bin/env python3
"""
Sophia AI Workflow Automation
Zencoder-style autonomous agents for development workflows
"""

import asyncio
import json
import subprocess
import sys
from pathlib import Path

class SophiaWorkflowRunner:
    def __init__(self):
        self.base_url = "http://localhost:8000"
        self.workflows_dir = Path(".sophia/workflows")
    
    async def run_workflow(self, workflow_type, context):
        """Run automated workflow"""
        workflows = {
            "issue_to_code": self.workflow_issue_to_code,
            "code_review": self.workflow_code_review,
            "bug_fix": self.workflow_bug_fix,
            "performance_optimization": self.workflow_performance_optimization,
            "security_scan": self.workflow_security_scan
        }
        
        if workflow_type not in workflows:
            print(f"‚ùå Unknown workflow: {workflow_type}")
            return
        
        print(f"ü§ñ Running workflow: {workflow_type}")
        await workflows[workflow_type](context)
    
    async def workflow_issue_to_code(self, context):
        """Automated workflow: Issue to Code"""
        print("üîÑ Analyzing issue...")
        
        # 1. Use Sophia AI to analyze issue
        analysis_result = subprocess.run([
            "python", "unified_ai_assistant.py", 
            f"Analyze this issue and create implementation plan: {context.get('description', '')}"
        ], capture_output=True, text=True)
        
        print("üìã Implementation plan created")
        
        # 2. Generate code using Claude
        code_result = subprocess.run([
            "./claude-cli-integration/claude", "chat",
            f"Generate code for: {context.get('title', '')}\\n\\nPlan: {analysis_result.stdout}"
        ], capture_output=True, text=True)
        
        print("üíª Code generated")
        
        # 3. Run security scan
        print("üîí Running security scan...")
        
        # 4. Save results
        results = {
            "workflow": "issue_to_code",
            "issue": context,
            "analysis": analysis_result.stdout,
            "generated_code": code_result.stdout,
            "status": "completed"
        }
        
        results_file = self.workflows_dir / f"issue_to_code_{context.get('id', 'unknown')}.json"
        results_file.parent.mkdir(exist_ok=True)
        with open(results_file, 'w') as f:
            json.dump(results, f, indent=2)
        
        print(f"‚úÖ Workflow completed. Results saved to {results_file}")
    
    async def workflow_code_review(self, context):
        """Automated code review workflow"""
        print("üîç Performing automated code review...")
        
        # Use Sophia AI for comprehensive review
        review_result = subprocess.run([
            "python", "unified_ai_assistant.py",
            f"Perform comprehensive code review including security, performance, and business logic analysis for: {context.get('code', '')}"
        ], capture_output=True, text=True)
        
        print("üìä Code review completed")
        print(review_result.stdout)

async def main():
    if len(sys.argv) < 3:
        print("Usage: python sophia_workflow_runner.py <workflow_type> <context_json>")
        print("Available workflows: issue_to_code, code_review, bug_fix, performance_optimization, security_scan")
        return
    
    workflow_type = sys.argv[1]
    context = json.loads(sys.argv[2])
    
    runner = SophiaWorkflowRunner()
    await runner.run_workflow(workflow_type, context)

if __name__ == "__main__":
    asyncio.run(main())
'''

    with open("sophia_workflow_runner.py", "w") as f:
        f.write(workflow_runner)

    os.chmod("sophia_workflow_runner.py", 0o755)

    print("  ‚úÖ Workflow automation created")


def test_integration():
    """Test the integration"""
    try:
        # Test unified assistant
        result = subprocess.run(
            ["python", "unified_ai_assistant.py", "status"],
            capture_output=True,
            text=True,
            timeout=10,
        )

        if result.returncode == 0:
            print("  ‚úÖ Unified AI assistant working")
        else:
            print("  ‚ö†Ô∏è Unified AI assistant issues detected")

        # Test Claude CLI
        result = subprocess.run(
            ["python", "claude-cli-integration/claude_cli.py", "models"],
            capture_output=True,
            text=True,
            timeout=10,
        )

        if result.returncode == 0:
            print("  ‚úÖ Claude CLI working")
        else:
            print("  ‚ö†Ô∏è Claude CLI issues detected")

    except Exception as e:
        print(f"  ‚ö†Ô∏è Testing error: {e}")


def show_usage_examples():
    """Show usage examples"""
    print("\nüéØ **ENHANCED CODING WORKFLOW - USAGE EXAMPLES**")
    print("=" * 60)

    examples = [
        (
            "üîß Initialize enhanced workspace",
            "python enhanced_coding_workflow_integration.py init",
        ),
        ("üìù List available prompts", "python sophia_prompt_manager.py list prompts"),
        (
            "ü§ñ Run issue-to-code workflow",
            'python sophia_workflow_runner.py issue_to_code \'{"title":"Fix login bug","description":"Users cannot login"}\'',
        ),
        (
            "üíª Generate code with context",
            'python enhanced_coding_workflow_integration.py generate --prompt react-component --context \'{"component_name":"UserAuth"}\'',
        ),
        (
            "üåê Use Chrome extension",
            "1. Load sophia-chrome-extension in Chrome Dev Mode\\n   2. Visit GitHub/Linear/Jira\\n   3. Click 'Send to Sophia AI' button",
        ),
        (
            "üí° VS Code integration",
            "1. Install sophia-vscode-extension\\n   2. Use Ctrl+Shift+G for code generation\\n   3. Use Ctrl+Shift+S for chat",
        ),
    ]

    for desc, cmd in examples:
        print(f"\n{desc}:")
        print(f"   {cmd}")

    print("\nüöÄ **YOUR ADVANTAGES OVER ZENCODER & CURSOR-COMPANION:**")
    print("‚úÖ Latest Claude Sonnet 4 with intelligent routing")
    print("‚úÖ Business intelligence integration (unique)")
    print("‚úÖ Real-time dashboard and metrics (unique)")
    print("‚úÖ Infrastructure automation (unique)")
    print("‚úÖ Cross-platform workflow (CLI + Web + Extensions)")
    print("‚úÖ Enterprise-grade security with Pulumi ESC")
    print("‚úÖ MCP server orchestration for specialized tasks")


if __name__ == "__main__":
    setup_enhanced_workflow()
