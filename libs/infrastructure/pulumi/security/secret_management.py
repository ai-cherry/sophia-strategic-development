from backend.services.unified_memory_service_primary import UnifiedMemoryService
from __future__ import annotations

import os

"""Enhanced Security and Secret Management for Sophia AI Platform.

Comprehensive secret management with Pulumi ESC integration, automatic validation,
rotation monitoring, and enterprise-grade security features.
"""

"""
File Decomposition Plan (auto-generated by Phase 3)
Current size: 786 lines

Recommended decomposition:
- secret_management_core.py - Core functionality
- secret_management_utils.py - Utility functions
- secret_management_models.py - Data models
- secret_management_handlers.py - Request handlers

"""

import hashlib
import logging
from datetime import UTC, datetime, timedelta
from enum import Enum
from typing import Any

import httpx
from cryptography.fernet import Fernet
from jose import jwt
from pydantic import BaseModel, Field

from backend.core.auto_esc_config import get_config_value as config

logger = logging.getLogger(__name__)


class SecretType(str, Enum):
    """Types of secrets managed by the platform."""

    API_KEY = "api_key"
    OAUTH_TOKEN = "oauth_token"
    DATABASE_PASSWORD = os.getenv(
        "DATABASE_PASSWORD"
    )  # SECURITY FIX: Use environment variable
    JWT_KEY = "jwt_key"
    ENCRYPTION_KEY = "encryption_key"
    WEBHOOK_SECRET = os.getenv(
        "WEBHOOK_SECRET"
    )  # SECURITY FIX: Use environment variable
    CERTIFICATE = "certificate"


class SecretStatus(str, Enum):
    """Secret status enumeration."""

    ACTIVE = "active"
    EXPIRING = "expiring"
    EXPIRED = "expired"
    ROTATING = "rotating"
    FAILED = "failed"


class SecurityLevel(str, Enum):
    """Security levels for different operations."""

    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


class SecretMetadata(BaseModel):
    """Metadata for a managed secret."""

    name: str
    secret_type: SecretType
    security_level: SecurityLevel
    created_at: datetime
    last_rotated: datetime | None = None
    expires_at: datetime | None = None
    rotation_interval_days: int = 90
    status: SecretStatus = SecretStatus.ACTIVE
    tags: list[str] = Field(default_factory=list)
    owner: str = "sophia-platform"
    description: str | None = None


class SecretRotationResult(BaseModel):
    """Result of a secret rotation operation."""

    secret_name: str
    success: bool
    old_secret_hash: str | None = None
    new_secret_hash: str | None = None
    rotated_at: datetime
    error_message: str | None = None
    next_rotation: datetime | None = None


class SecurityAuditEvent(BaseModel):
    """Security audit event."""

    event_id: str
    event_type: str
    timestamp: datetime
    user_id: str | None = None
    resource: str
    action: str
    status: str
    ip_address: str | None = None
    user_agent: str | None = None
    additional_data: dict[str, Any] = Field(default_factory=dict)


class SecretManager:
    """Enhanced secret management with Pulumi ESC integration."""

    def __init__(self):
        self.config = config
        self.logger = logger.bind(component="secret_manager")

        # Initialize encryption components
        self._encryption_key = self._get_or_create_encryption_key()
        self._fernet = Fernet(self._encryption_key)

        # Secret metadata storage (in production, this would be a database)
        self._secret_metadata: dict[str, SecretMetadata] = {}

        # Audit log storage (in production, this would be a database)
        self._audit_log: list[SecurityAuditEvent] = []

        # Monitoring clients
        self._monitoring_client = None
        self._notification_client = None

        self.logger.info("Secret manager initialized")

    def _get_or_create_encryption_key(self) -> bytes:
        """Get or create encryption key for local secret encryption."""
        encryption_key = self.config.encryption_key

        if not encryption_key:
            # Generate a new key
            key = Fernet.generate_key()
            self.logger.warning(
                "Generated new encryption key - should be stored in ESC"
            )
            return key

        # Convert ESC key to bytes
        try:
            if isinstance(encryption_key, str):
                # Assume base64 encoded
                import base64

                return base64.urlsafe_b64decode(encryption_key.encode())
            return encryption_key
        except Exception as e:
            self.logger.exception(f"Failed to decode encryption key: {e}")
            # Fallback to new key
            return Fernet.generate_key()

    async def validate_secrets(self) -> dict[str, bool]:
        """Validate all required secrets are accessible and functional."""
        validation_results = {}

        try:
            # Critical service validations
            validation_results.update(await self._validate_core_secrets())
            validation_results.update(await self._validate_ai_services())
            validation_results.update(await self._validate_infrastructure_secrets())
            validation_results.update(await self._validate_monitoring_secrets())
            validation_results.update(await self._validate_extended_api_services())

            # Log validation summary
            successful = sum(1 for result in validation_results.values() if result)
            total = len(validation_results)

            self.logger.info(
                "Secret validation completed",
                successful=successful,
                total=total,
                success_rate=(
                    f"{(successful / total * 100):.1f}%" if total > 0 else "0%"
                ),
            )

            # Store audit event
            await self._audit_log_event(
                event_type="secret_validation",
                resource="all_secrets",
                action="validate",
                status="completed",
                additional_data={"results": validation_results},
            )

            return validation_results

        except Exception as e:
            self.logger.exception(f"Secret validation failed: {e!s}")
            await self._audit_log_event(
                event_type="secret_validation",
                resource="all_secrets",
                action="validate",
                status="failed",
                additional_data={"error": str(e)},
            )
            return validation_results

    async def _validate_core_secrets(self) -> dict[str, bool]:
        """Validate core platform secrets."""
        results = {}

        # Webhook JWT keys
        if self.config.webhook_jwt_private_key and self.config.webhook_jwt_public_key:
            results["webhook_jwt"] = await self._validate_jwt_keys()

        # Agent authentication
        if self.config.agent_orchestrator_auth_token:
            results["agent_auth"] = self._validate_token_format(
                self.config.agent_orchestrator_auth_token
            )

        # Agent communication secret
        if self.config.agent_communication_secret:
            results["agent_communication"] = self._validate_token_format(
                self.config.agent_communication_secret
            )

        return results

    async def _validate_ai_services(self) -> dict[str, bool]:
        """Validate AI service API keys."""
        results = {}

        # OpenAI
        if self.config.openai_api_key:
            results["openai"] = await self._validate_openai_key()

        # Anthropic
        if self.config.anthropic_api_key:
            results["anthropic"] = await self._validate_anthropic_key()

        # Agno
        if self.config.agno_api_key:
            results["agno"] = self._validate_token_format(self.config.agno_api_key)

        return results

    async def _validate_infrastructure_secrets(self) -> dict[str, bool]:
        """Validate infrastructure secrets."""
        results = {}

        # Qdrant

            results["qdrant"] = await self._validate_QDRANT_credentials()

        # Redis
        if self.config.redis_password:
            results["redis"] = await self._validate_redis_credentials()

        # Gong
        if self.config.gong_access_key and self.config.gong_client_secret:
            results["gong"] = await self._validate_gong_credentials()

        return results

    async def _validate_monitoring_secrets(self) -> dict[str, bool]:
        """Validate monitoring service secrets."""
        results = {}

        # Arize
        if self.config.arize_api_key:
            results["arize"] = await self._validate_arize_key()

        # Sentry
        if self.config.sentry_dsn:
            results["sentry"] = self._validate_sentry_dsn()

        # Prometheus
        if self.config.prometheus_auth_token:
            results["prometheus"] = self._validate_token_format(
                self.config.prometheus_auth_token
            )

        return results

    async def _validate_extended_api_services(self) -> dict[str, bool]:
        """Validate extended API service secrets."""
        results = {}

        # Asana
        if self.config.asana_pat_token:
            results["asana"] = await self._validate_asana_credentials()

        # Salesforce
        if self.config.salesforce_access_token:
            results["salesforce"] = await self._validate_salesforce_credentials()

        # Enhanced Slack
        if (
            self.config.slack_client_secret
            and self.config.slack_signing_secret
            and self.config.slack_app_token
        ):
            results[
                "slack_enhanced"
            ] = await self._validate_slack_enhanced_credentials()

        return results

    async def _validate_asana_credentials(self) -> bool:
        """Validate Asana API credentials."""
        try:
            async with httpx.AsyncClient() as client:
                response = await client.get(
                    "https://app.asana.com/api/1.0/users/me",
                    headers={
                        "Authorization": f"Bearer {self.config.asana_pat_token}",
                        "Content-Type": "application/json",
                    },
                    timeout=10,
                )

                success = response.status_code == 200
                self.logger.info("Asana API validation", success=success)
                return success

        except Exception as e:
            self.logger.exception(f"Asana API validation failed: {e}")
            return False

    async def _validate_salesforce_credentials(self) -> bool:
        """Validate Salesforce API credentials."""
        try:
            # Basic token format validation
            token = self.config.salesforce_access_token

            if not token or len(token) < 50:
                return False

            # Salesforce tokens have specific format characteristics
            if not token.startswith(("00D", "6Cel")):
                return False

            self.logger.info("Salesforce credentials format validated")
            return True

        except Exception as e:
            self.logger.exception(f"Salesforce validation failed: {e}")
            return False

    async def _validate_slack_enhanced_credentials(self) -> bool:
        """Validate enhanced Slack credentials."""
        try:
            # Validate token formats
            client_secret = self.config.slack_client_secret
            signing_secret = self.config.slack_signing_secret
            app_token = self.config.slack_app_token

            if not all([client_secret, signing_secret, app_token]):
                return False

            # Basic format validation
            if (
                len(client_secret) < 30
                or len(signing_secret) < 30
                or not app_token.startswith("xapp-")
            ):
                return False

            self.logger.info("Enhanced Slack credentials format validated")
            return True

        except Exception as e:
            self.logger.exception(f"Enhanced Slack validation failed: {e}")
            return False

    async def _validate_jwt_keys(self) -> bool:
        """Validate JWT key pair."""
        try:
            # Test signing and verification
            test_payload = {
                "test": "data",
                "exp": datetime.now(UTC) + timedelta(minutes=1),
            }

            # Sign with private key
            token = jwt.encode(
                test_payload, self.config.webhook_jwt_private_key, algorithm="RS256"
            )

            # Verify with public key
            decoded = jwt.decode(
                token, self.config.webhook_jwt_public_key, algorithms=["RS256"]
            )

            success = decoded.get("test") == "data"
            self.logger.info("JWT key validation", success=success)
            return success

        except Exception as e:
            self.logger.exception(f"JWT key validation failed: {e}")
            return False

    async def _validate_openai_key(self) -> bool:
        """Validate OpenAI API key."""
        try:
            async with httpx.AsyncClient() as client:
                response = await client.get(
                    "https://api.openai.com/v1/models",
                    headers={
                        "Authorization": f"Bearer {self.config.openai_api_key}",
                        "Content-Type": "application/json",
                    },
                    timeout=10,
                )

                success = response.status_code == 200
                self.logger.info("OpenAI API validation", success=success)
                return success

        except Exception as e:
            self.logger.exception(f"OpenAI API validation failed: {e}")
            return False

    async def _validate_anthropic_key(self) -> bool:
        """Validate Anthropic API key."""
        try:
            async with httpx.AsyncClient() as client:
                # Test with a minimal request that validates auth
                response = await client.post(
                    "https://api.anthropic.com/v1/messages",
                    headers={
                        "x-api-key": self.config.anthropic_api_key,
                        "Content-Type": "application/json",
                        "anthropic-version": "2023-06-01",
                    },
                    json={
                        "model": "claude-3-haiku-20240307",
                        "max_tokens": 1,
                        "messages": [{"role": "user", "content": "test"}],
                    },
                    timeout=10,
                )

                # 200 or 4xx (but not 401/403) indicates valid auth
                success = response.status_code not in [401, 403]
                self.logger.info(
                    "Anthropic API validation",
                    success=success,
                    status_code=response.status_code,
                )
                return success

        except Exception as e:
            self.logger.exception(f"Anthropic API validation failed: {e}")
            return False

    async def _validate_QDRANT_credentials(self) -> bool:
        """Validate Qdrant credentials."""
        try:
            # In production, this would use actual Qdrant connector
            # For now, just validate format and presence
            account = self.config.postgres_host
            password = self.config.postgres_password

            if not account or not password:
                return False

            # Basic format validation
            if len(account) < 5 or len(password) < 8:
                return False

            self.logger.info("Qdrant credentials format validated")
            return True

        except Exception as e:
            self.logger.exception(f"Qdrant validation failed: {e}")
            return False

    async def _validate_redis_credentials(self) -> bool:
        """Validate Redis credentials."""
        try:
            # In production, this would test actual Redis connection
            password = self.config.redis_password

            if not password or len(password) < 8:
                return False

            self.logger.info("Redis credentials format validated")
            return True

        except Exception as e:
            self.logger.exception(f"Redis validation failed: {e}")
            return False

    async def _validate_gong_credentials(self) -> bool:
        """Validate Gong API credentials."""
        try:
            access_key = self.config.gong_access_key
            secret_key = self.config.gong_client_secret

            if not access_key or not secret_key:
                return False

            # Test API call
            async with httpx.AsyncClient() as client:
                response = await client.get(
                    f"{self.config.gong_api_base_url}/v2/calls",
                    auth=httpx.BasicAuth(access_key, secret_key),
                    params={"limit": 1},
                    timeout=10,
                )

                success = response.status_code == 200
                self.logger.info("Gong API validation", success=success)
                return success

        except Exception as e:
            self.logger.exception(f"Gong API validation failed: {e}")
            return False

    async def _validate_arize_key(self) -> bool:
        """Validate Arize API key."""
        try:
            # Simple format validation
            api_key = self.config.arize_api_key

            if not api_key or len(api_key) < 10:
                return False

            self.logger.info("Arize API key format validated")
            return True

        except Exception as e:
            self.logger.exception(f"Arize validation failed: {e}")
            return False

    def _validate_sentry_dsn(self) -> bool:
        """Validate Sentry DSN format."""
        try:
            dsn = self.config.sentry_dsn

            if not dsn:
                return False

            # Basic DSN format validation
            if not dsn.startswith(("https://", "http://")):
                return False

            if "@" not in dsn:
                return False

            self.logger.info("Sentry DSN format validated")
            return True

        except Exception as e:
            self.logger.exception(f"Sentry DSN validation failed: {e}")
            return False

    def _validate_token_format(self, token: str) -> bool:
        """Validate basic token format."""
        try:
            if not token or len(token) < 16:
                return False

            # Check for basic token characteristics
            if token.count(".") > 0:  # JWT-like
                return len(token.split(".")) >= 2

            # Regular token
            return len(token) >= 16 and token.isalnum()

        except Exception as e:
            self.logger.exception(f"Token format validation failed: {e}")
            return False

    async def setup_secret_rotation_monitoring(self) -> None:
        """Set up monitoring for secret rotation schedules."""
        try:
            # Initialize secret metadata for known secrets
            await self._initialize_secret_metadata()

            # Check for secrets nearing expiration
            expiring_secrets = await self._check_expiring_secrets()

            if expiring_secrets:
                await self._notify_expiring_secrets(expiring_secrets)

            self.logger.info(
                "Secret rotation monitoring setup completed",
                monitored_secrets=len(self._secret_metadata),
                expiring_secrets=len(expiring_secrets),
            )

        except Exception as e:
            self.logger.exception(f"Secret rotation monitoring setup failed: {e}")

    async def _initialize_secret_metadata(self) -> None:
        """Initialize metadata for all managed secrets."""
        now = datetime.now(UTC)

        # Define secret configurations
        secret_configs = [
            ("openai_api_key", SecretType.API_KEY, SecurityLevel.HIGH, 180),
            ("anthropic_api_key", SecretType.API_KEY, SecurityLevel.HIGH, 180),
            ("gong_access_key", SecretType.API_KEY, SecurityLevel.CRITICAL, 90),
            ("gong_client_secret", SecretType.API_KEY, SecurityLevel.CRITICAL, 90),
            (
                "postgres_password",
                SecretType.DATABASE_PASSWORD,
                SecurityLevel.CRITICAL,
                90,
            ),
            ("redis_password", SecretType.DATABASE_PASSWORD, SecurityLevel.HIGH, 90),
            (
                "webhook_jwt_private_key",
                SecretType.JWT_KEY,
                SecurityLevel.CRITICAL,
                365,
            ),
            (
                "agent_orchestrator_auth_token",
                SecretType.API_KEY,
                SecurityLevel.HIGH,
                90,
            ),
            (
                "agent_communication_secret",
                SecretType.ENCRYPTION_KEY,
                SecurityLevel.HIGH,
                90,
            ),
        ]

        for name, secret_type, security_level, rotation_days in secret_configs:
            if name not in self._secret_metadata:
                self._secret_metadata[name] = SecretMetadata(
                    name=name,
                    secret_type=secret_type,
                    security_level=security_level,
                    created_at=now,
                    rotation_interval_days=rotation_days,
                    expires_at=now + timedelta(days=rotation_days),
                )

    async def _check_expiring_secrets(self) -> list[SecretMetadata]:
        """Check for secrets that are expiring soon."""
        now = datetime.now(UTC)
        warning_threshold = timedelta(days=7)  # Warn 7 days before expiration

        expiring_secrets = []

        for metadata in self._secret_metadata.values():
            if metadata.expires_at and metadata.expires_at - now <= warning_threshold:
                if metadata.status != SecretStatus.ROTATING:
                    metadata.status = SecretStatus.EXPIRING
                    expiring_secrets.append(metadata)

        return expiring_secrets

    async def _notify_expiring_secrets(
        self, expiring_secrets: list[SecretMetadata]
    ) -> None:
        """Notify about expiring secrets."""
        for secret in expiring_secrets:
            await self._audit_log_event(
                event_type="secret_expiring",
                resource=secret.name,
                action="expiration_warning",
                status="warning",
                additional_data={
                    "expires_at": (
                        secret.expires_at.isoformat() if secret.expires_at else None
                    ),
                    "security_level": secret.security_level,
                    "rotation_interval_days": secret.rotation_interval_days,
                },
            )

            self.logger.warning(
                "Secret expiring soon",
                secret_name=secret.name,
                expires_at=secret.expires_at,
                security_level=secret.security_level,
            )

    async def audit_secret_access(
        self, secret_name: str, access_context: dict[str, Any]
    ) -> None:
        """Audit secret access for compliance."""
        await self._audit_log_event(
            event_type="secret_access",
            resource=secret_name,
            action="access",
            status="success",
            user_id=access_context.get("user_id"),
            ip_address=access_context.get("ip_address"),
            user_agent=access_context.get("user_agent"),
            additional_data=access_context,
        )

    async def _audit_log_event(
        self,
        event_type: str,
        resource: str,
        action: str,
        status: str,
        user_id: str | None = None,
        ip_address: str | None = None,
        user_agent: str | None = None,
        additional_data: dict[str, Any] | None = None,
    ) -> None:
        """Log a security audit event."""
        event = SecurityAuditEvent(
            event_id=self._generate_event_id(),
            event_type=event_type,
            timestamp=datetime.now(UTC),
            user_id=user_id,
            resource=resource,
            action=action,
            status=status,
            ip_address=ip_address,
            user_agent=user_agent,
            additional_data=additional_data or {},
        )

        self._audit_log.append(event)

        # In production, this would send to Qdrant or other audit storage
        self.logger.info(
            "Security audit event logged",
            event_type=event_type,
            resource=resource,
            action=action,
            status=status,
            event_id=event.event_id,
        )

    def _generate_event_id(self) -> str:
        """Generate a unique event ID."""
        import uuid

        return str(uuid.uuid4())

    def get_secret_hash(self, secret_value: str) -> str:
        """Generate a hash of a secret value for comparison."""
        return hashlib.sha256(secret_value.encode()).hexdigest()[:16]

    def encrypt_secret(self, secret_value: str) -> str:
        """Encrypt a secret value for local storage."""
        return self._fernet.encrypt(secret_value.encode()).decode()

    def decrypt_secret(self, encrypted_value: str) -> str:
        """Decrypt a secret value from local storage."""
        return self._fernet.decrypt(encrypted_value.encode()).decode()

    async def get_security_status(self) -> dict[str, Any]:
        """Get overall security status."""
        now = datetime.now(UTC)

        # Count secrets by status
        status_counts = {}
        for status in SecretStatus:
            status_counts[status.value] = sum(
                1
                for metadata in self._secret_metadata.values()
                if metadata.status == status
            )

        # Count by security level
        security_level_counts = {}
        for level in SecurityLevel:
            security_level_counts[level.value] = sum(
                1
                for metadata in self._secret_metadata.values()
                if metadata.security_level == level
            )

        # Recent audit events
        recent_events = len(
            [
                event
                for event in self._audit_log
                if (now - event.timestamp).total_seconds() < 3600  # Last hour
            ]
        )

        return {
            "total_secrets": len(self._secret_metadata),
            "secrets_by_status": status_counts,
            "secrets_by_security_level": security_level_counts,
            "recent_audit_events": recent_events,
            "last_validation": getattr(self, "_last_validation", None),
            "encryption_key_set": self._encryption_key is not None,
            "audit_log_size": len(self._audit_log),
        }


# Global instance
secret_manager = SecretManager()
